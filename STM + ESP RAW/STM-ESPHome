#include <ModbusMaster.h>
#include <SPI.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_INA219.h>

// Pin MAX485
#define MAX485_DE      PA0
#define MAX485_RE      PA1

// Pin Relay
#define RELAY_Inv      PB15
#define RELAY_Batt     PB14
#define RELAY_ATS_N    PB13
#define RELAY_ATS_F    PB12

// SPI
#define SPI1_NSS_PIN PA4  // SPI_1 digunakan untuk komunikasi dengan SD Card

// Alamat slave untuk PZEM
static uint8_t pzemSlaveAddrPanel = 0x01;
static uint8_t pzemSlaveAddrBattery = 0x02;
static uint8_t pzemSlaveAddrAC = 0x03;

// Objek ModbusMaster
ModbusMaster nodePanel;
ModbusMaster nodeBattery;
ModbusMaster nodeAC;
Adafruit_INA219 ina219;
 
// Variabel untuk PZEM Panel
float PZEMVoltagePanel = 0.00, PZEMCurrentPanel = 0.00, PZEMPowerPanel = 0.00, PZEMEnergyPanel = 0.00;

// Variabel untuk PZEM Baterai
float PZEMVoltageBattery = 0.00, PZEMCurrentBattery = 0.00, PZEMPowerBattery = 0.00, PZEMEnergyBattery = 0.00;

// Variable untuk PSEM AC
float voltageAC, currentAC, powerAC, energyAC, frequencyAC, powerFactorAC;

// Variabel untuk PZEM AC PLTS
float PLTSVoltage = 0.00, PLTSCurrent = 0.00, PLTSPower = 0.00, PLTSEnergy = 5, PLTSHz = 0.00, PLTSPf = 0.00;

// Variabel untuk PZEM AC Grid
float GridVoltage = 0.00, GridCurrent = 0.00, GridPower = 0.00, GridEnergy = 4, GridHz = 0.00, GridPf = 0.00;

// Variabel untuk INA219
float ShuntVoltage = 0.00, INA219Voltage = 0.00, INA219Current = 0.00;
bool ina219Available = false;  // Flag untuk track status INA219

// Tambahan variabel BMS
float v1 = 0.0, v2 = 0.0, v3 = 0.0, v4 = 0.0;
float total_voltage = 0.0, soc = 0.0;

// Variabel untuk menerima data ESP32 - TAMBAH BMS DATA
unsigned long espTimestamp = 0;
float espLux = 0.0, espTemp1 = 0.0, espTemp2 = 0.0;
float espVoltage = 0.0, espSOC = 0.0;  // TAMBAHAN: Data BMS dari ESP32
bool espDataReceived = false;
unsigned long lastESP32Time = 0;

// ===== VARIABEL GLOBAL TIMEREF =====
unsigned long globalTimeRef = 0;        // Timestamp referensi global
unsigned long globalTimeRefBaseMillis = 0; // Basis millis() saat timeref di-set
bool timeRefAvailable = false;           // Flag ketersediaan timeref
unsigned long lastTimeRefUpdate = 0;     // Terakhir kali timeref diupdate
const unsigned long timeRefUpdateInterval = 300000; // Update timeref setiap 5 menit

// ===== VARIABEL OFFLINE AUTO INCREMENT =====
unsigned long lastOfflineTimestamp = 0;     // Timestamp terakhir saat offline
unsigned long lastOfflineMillis = 0;        // Millis terakhir saat offline increment
bool isOfflineMode = false;                  // Flag mode offline
const unsigned long offlineIncrementInterval = 60000;  // 60 detik (1 menit)

// ===== VARIABEL TIMESTAMP SYNC TERPISAH =====
bool freshTimestampReceived = false;        // Flag timestamp fresh diterima
unsigned long lastTimestampSync = 0;        // Waktu terakhir dapat timestamp sync
unsigned long lastTimestampValue = 0;       // Nilai timestamp terakhir dari sync

// ===== STRUKTUR DATA UNTUK FIFO BUFFER =====
struct DataRecord {
    int no;
    char waktu[10];
    unsigned long timestamp;  // Unix timestamp dari ESP32
    float soci2_v_pv, soci2_i_pv, soci2_p_pv, soci2_e_pv;
    float soci2_v_batt, soci2_i_batt, soci2_p_batt, soci2_e_batt, soci2_soc;
    float bms_v1, bms_v2, bms_v3, bms_v4, bms_total_v, bms_soc;
    float energi_p_batt, energi_e_batt, energi_soc;
    float energi_plts_p, energi_plts_e, energi_grid_p, energi_grid_e;
    float energi_lux, energi_temp1, energi_temp2;
    int pendingWrites;  // Bitmask: 1=SOCi2, 2=BMS, 4=Energi
};

// FIFO Buffer (ukuran 20 slot)
#define FIFO_SIZE 20
DataRecord fifoBuffer[FIFO_SIZE];
int fifoHead = 0;
int fifoTail = 0;
int fifoCount = 0;

// Timer untuk ESP32
unsigned long startMillisESP;
unsigned long currentMillisESP;
const unsigned long periodESP = 300000;  // 5 menit timeout (60s data + 4 menit grace period)

// State Machine untuk penulisan file sekuensial
enum WriteState {
    WRITE_IDLE = 0,
    WRITE_SOCI2 = 1,
    WRITE_BMS = 2,
    WRITE_ENERGI = 3,
    WRITE_CLEANUP = 4
};
WriteState currentWriteState = WRITE_IDLE;

// Timer untuk state machine penulisan
unsigned long writeStateTimer = 0;
const unsigned long writeStateDelay = 100;  // 100ms delay antar penulisan file (dipercepat untuk testing)

// Pengolahan Data
int previousStatus = -1;  // Inisialisasi dengan nilai tidak valid
int count = 0, SOCt = 0, Ah = 100, interval = 0;
float deltaT = 0.0, SOCo = 0.0, kapasitas = 0.0;
char waktu[10];

// Status Alat Terkini
int statusbatt = 0, statuscsv = 0;

// Variable callback
const char* hari = "";
const char* bulan = "";
int tanggal, tahun, jam, menit, detik;

// Variabel global yang dibutuhkan
bool isPLTS = false;                  // true = relay ON (pakai PLTS)
bool waitToTurnOn = false;           // status delay sebelum ON
unsigned long timeToTurnOn = 0;      // waktu mulai delay

//Timer untuk Pembaharuan Data
unsigned long startMillisPZEM;
unsigned long currentMillisPZEM;
const unsigned long periodPZEM = 300000; // 5 menit (1 menit data + 4 menit buffer)

//Timer untuk INA219
unsigned long startMillisINA;
unsigned long currentMillisINA;
const unsigned long periodINA = 300000; // 5 menit (sinkron dengan PZEM)

//Timer untuk ATS
unsigned long startMillisATS;
unsigned long currentMillisATS;
const unsigned long periodATS = 300000; // 5 menit (sinkron dengan PZEM)

//Timer untuk SD CARD (1 menit per cycle)
unsigned long startMillisSOC;
unsigned long currentMillisSOC;
const unsigned long periodSOC = 60000;  // 60 detik (1 menit) untuk 1 cycle data logging

//Timer untuk SD Card Check (setiap 30 detik)
unsigned long startMillisSDCheck;
unsigned long currentMillisSDCheck;
const unsigned long periodSDCheck = 30000;  // 30 detik

// Timer untuk tracking last write time
unsigned long lastWriteTime = 0;

// Status SD Card
bool sdCardAvailable = true;
bool sdCardWasRemoved = false;  // Flag untuk track jika SD card pernah dicabut
bool isRecursiveCheck = false;  // Proteksi terhadap rekursi berlebihan

void setup() {
  // Serial Monitor
  Serial.begin(9600);
  while (!Serial);
  
  // Debug: Pastikan serial terhubung
  delay(2000);
  Serial.println("\n\n========== STARTUP ==========");
  Serial.println("STM32 System Starting...");

  // Komunikasi Antar Perangkat
  Serial2.begin(9600, SERIAL_8N2); // Untuk komunikasi PZEM
  Serial3.begin(9600);  // Untuk komunikasi dengan ESP32 (9600 baud)
  delay(500);
  Serial.println("‚úì Serial2 & Serial3 initialized");
  Serial.println("‚Ñπ Serial3: 9600 baud for ESP32 communication");

  pinMode(SPI1_NSS_PIN, OUTPUT);
  digitalWrite(SPI1_NSS_PIN, HIGH);

  // Inisialisasi SD Card
  Serial.print("Initializing SD card...");
  digitalWrite(SPI1_NSS_PIN, LOW);
  if (!SD.begin(SPI1_NSS_PIN)) {
    Serial.println("initialization failed!");
    while (1);
  }
  Serial.println("initialization done.");
  Serial.println("‚úì SD Card initialized");
  digitalWrite(SPI1_NSS_PIN, HIGH);
  delay(500);

  // Konfigurasi MAX485
  pinMode(MAX485_RE, OUTPUT);
  pinMode(MAX485_DE, OUTPUT);
  digitalWrite(MAX485_RE, 0);
  digitalWrite(MAX485_DE, 0);
  Serial.println("‚úì MAX485 configured");

  // Konfigurasi Relay
  pinMode(RELAY_ATS_F, OUTPUT);
  pinMode(RELAY_Inv, OUTPUT);
  pinMode(RELAY_Batt, OUTPUT);
  pinMode(RELAY_ATS_N, OUTPUT);

  digitalWrite(RELAY_ATS_F, HIGH);
  digitalWrite(RELAY_Inv, HIGH);
  digitalWrite(RELAY_Batt, HIGH);
  digitalWrite(RELAY_ATS_N, HIGH);
  Serial.println("‚úì Relays configured");

  // Inisialisasi Modbus
  nodePanel.begin(pzemSlaveAddrPanel, Serial2);
  nodePanel.preTransmission(preTransmission);
  nodePanel.postTransmission(postTransmission);

  nodeBattery.begin(pzemSlaveAddrBattery, Serial2);
  nodeBattery.preTransmission(preTransmission);
  nodeBattery.postTransmission(postTransmission);

  nodeAC.begin(pzemSlaveAddrAC, Serial2);
  nodeAC.preTransmission(preTransmission);
  nodeAC.postTransmission(postTransmission);
  Serial.println("‚úì Modbus initialized");

  // Inisialisasi I2C (Wire)
  Serial.println("Initializing Wire (I2C)...");
  Wire.begin();
  delay(500);
  Serial.println("‚úì Wire (I2C) initialized");
  
  // Inisialisasi INA219
  if (! ina219.begin())
  {
    Serial.println("Failed to find INA219 chip");
    while (1) 
    {
      delay(10);
    }
  }
  ina219.setCalibration_32V_1A();
  ina219Available = true;
  Serial.println("‚úì INA219 initialized");

  startMillisPZEM = millis();
  startMillisSOC = millis();
  startMillisESP = millis();
  startMillisINA = millis();
  startMillisATS = millis();
  startMillisSDCheck = millis();
  
  // Inisialisasi file CSV di SD Card
  Serial.println("\nInitializing CSV files on SD Card...");
  initializeCSVFiles();
  
  // Inisialisasi TimeRef
  Serial.println("\nInitializing TimeRef system...");
  initializeTimeRef();
  
  Serial.println("========== STARTUP COMPLETE ==========\n");
}

void preTransmission() {
  digitalWrite(MAX485_RE, 1);
  digitalWrite(MAX485_DE, 1);
  delay(1);
}

// ===== FUNGSI INISIALISASI FILE CSV =====
void initializeCSVFiles() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Hapus file lama jika ada (opsional - uncomment jika ingin reset)
    // SD.remove("/SOCi2.csv");
    // SD.remove("/BMS.csv");
    // SD.remove("/Energi.csv");
    
    // === Inisialisasi SOCi2.csv ===
    if (!SD.exists("/SOCi2.csv")) {
        File file = SD.open("/SOCi2.csv", FILE_WRITE);
        if (file) {
            file.println("No,Waktu,Timestamp,Interval (s),V PV (V),I PV (A),P PV (W),E PV (Wh),V Batt (V),I Batt (A),P Batt (W),E Batt (Wh),SOC (%)");
            file.close();
            Serial.println("‚úì SOCi2.csv created with header");
        } else {
            Serial.println("‚ùå Failed to create SOCi2.csv");
        }
    } else {
        Serial.println("‚úì SOCi2.csv already exists");
    }
    
    // === Inisialisasi BMS.csv ===
    if (!SD.exists("/BMS.csv")) {
        File file = SD.open("/BMS.csv", FILE_WRITE);
        if (file) {
            file.println("No,Waktu,Timestamp,V1 (V),V2 (V),V3 (V),V4 (V),Total Voltage (V),SOC (%)");
            file.close();
            Serial.println("‚úì BMS.csv created with header");
        } else {
            Serial.println("‚ùå Failed to create BMS.csv");
        }
    } else {
        Serial.println("‚úì BMS.csv already exists");
    }
    
    // === Inisialisasi Energi.csv ===
    if (!SD.exists("/Energi.csv")) {
        File file = SD.open("/Energi.csv", FILE_WRITE);
        if (file) {
            file.println("No,Waktu,Timestamp,P Batt (W),E Batt (Wh),SOC (%),PLTS Power (W),PLTS Energy (Wh),Grid Power (W),Grid Energy (Wh),Lux (lx),Temp1 (C),Temp2 (C)");
            file.close();
            Serial.println("‚úì Energi.csv created with header");
        } else {
            Serial.println("‚ùå Failed to create Energi.csv");
        }
    } else {
        Serial.println("‚úì Energi.csv already exists");
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
    Serial.println("üì¶ All CSV files ready!\n");
}

// ===== FUNGSI PENGECEKAN DAN REINISIALISASI SD CARD =====
bool checkAndReinitializeSD() {
    // Proteksi terhadap rekursi berlebihan
    if (isRecursiveCheck) {
        Serial.println("üõ° [SD] Recursive check prevented!");
        return false;
    }
    
    // Coba akses SD card dengan membaca direktori root
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);  // Stabilisasi SPI
    
    File root = SD.open("/");
    if (!root) {
        // SD card tidak dapat diakses
        digitalWrite(SPI1_NSS_PIN, HIGH);
        Serial.println("‚ö† [SD] Card not accessible, attempting reinitialization...");
        
        // Set flag bahwa SD card pernah dicabut
        if (!sdCardWasRemoved) {
            sdCardWasRemoved = true;
            Serial.println("üö® [SD] Card removal detected!");
        }
        
        delay(500);  // Beri waktu lebih lama untuk stabilisasi
        
        // Reset SPI dan coba reinisialisasi beberapa kali
        for (int attempt = 1; attempt <= 3; attempt++) {
            Serial.print("üîÑ [SD] Reinit attempt ");
            Serial.print(attempt);
            Serial.println("/3...");
            
            digitalWrite(SPI1_NSS_PIN, LOW);
            delay(100);
            
            if (SD.begin(SPI1_NSS_PIN)) {
                Serial.println("‚úÖ [SD] Successfully reinitialized!");
                
                // VALIDATE FILE ACCESS CAPABILITY
                Serial.println("üß™ [SD] Testing file access after reinit...");
                File testAccess = SD.open("/SOCi2.csv", FILE_WRITE);
                if (testAccess) {
                    testAccess.close();
                    Serial.println("‚úÖ [SD] File access test SUCCESS!");
                } else {
                    Serial.println("‚ùå [SD] File access test FAILED - retrying...");
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    delay(500);
                    continue;  // Try next attempt
                }
                
                // Pastikan file CSV masih ada, jika tidak buat ulang
                if (!SD.exists("/SOCi2.csv") || !SD.exists("/BMS.csv") || !SD.exists("/Energi.csv")) {
                    Serial.println("üìã [SD] CSV files missing, recreating...");
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    initializeCSVFiles();
                }
                
                // Reset write state machine untuk memulai dari awal
                currentWriteState = WRITE_IDLE;
                writeStateTimer = millis();
                Serial.println("üîÑ [SD] Write state machine reset to IDLE");
                
                // Update status flags
                sdCardAvailable = true;
                sdCardWasRemoved = false;
                
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return true;
            } else {
                Serial.print("‚ùå [SD] Attempt ");
                Serial.print(attempt);
                Serial.println(" failed");
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(1000);  // Wait before next attempt
            }
        }
        
        Serial.println("‚ùå [SD] All reinitialization attempts FAILED!");
        sdCardAvailable = false;
        return false;
        
    } else {
        // SD card OK, tutup file dan VALIDATE FILE ACCESS
        root.close();
        
        // Test actual file access capability
        File testFile = SD.open("/SOCi2.csv", FILE_WRITE);
        if (!testFile) {
            Serial.println("‚ö† [SD] Directory OK but file access FAILED!");
            digitalWrite(SPI1_NSS_PIN, HIGH);
            
            // Set rekursi flag dan coba reinit sekali saja
            if (!isRecursiveCheck) {
                isRecursiveCheck = true;
                Serial.println("üîÑ [SD] Attempting single recovery for file access...");
                
                delay(500);  // Give SD card time to stabilize
                
                // Single attempt to reinit
                digitalWrite(SPI1_NSS_PIN, LOW);
                delay(100);
                
                if (SD.begin(SPI1_NSS_PIN)) {
                    Serial.println("‚úÖ [SD] Recovery reinit SUCCESS!");
                    
                    // Test file access again
                    File retestFile = SD.open("/SOCi2.csv", FILE_WRITE);
                    if (retestFile) {
                        retestFile.close();
                        Serial.println("‚úÖ [SD] File access RECOVERED!");
                        sdCardAvailable = true;
                        digitalWrite(SPI1_NSS_PIN, HIGH);
                        isRecursiveCheck = false;
                        return true;
                    } else {
                        Serial.println("‚ùå [SD] File access still FAILED after recovery");
                        sdCardAvailable = false;
                        digitalWrite(SPI1_NSS_PIN, HIGH);
                        isRecursiveCheck = false;
                        return false;
                    }
                } else {
                    Serial.println("‚ùå [SD] Recovery reinit FAILED");
                    sdCardAvailable = false;
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    isRecursiveCheck = false;
                    return false;
                }
            } else {
                Serial.println("üõ° [SD] Recursive check blocked - marking SD as unavailable");
                sdCardAvailable = false;
                return false;
            }
        }
        testFile.close();
        
        // Jika sebelumnya pernah dicabut, beri notifikasi recovery
        if (sdCardWasRemoved) {
            Serial.println("üîÑ [SD] Card reinserted and accessible!");
            sdCardWasRemoved = false;
            
            // Reset write state machine untuk memulai fresh
            currentWriteState = WRITE_IDLE;
            writeStateTimer = millis();
            Serial.println("üîÑ [SD] Ready to resume writing operations");
        }
        
        // Reset rekursi flag jika berhasil
        isRecursiveCheck = false;
        sdCardAvailable = true;
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return true;
    }
}

// ===== FUNGSI DEBUG SD CARD MANUAL =====
void debugSDCard() {
    Serial.println("\n=================== SD CARD DEBUG ===================");
    
    // Test 1: Cek status SPI
    Serial.print("üîß SPI NSS Pin Status: ");
    Serial.println(digitalRead(SPI1_NSS_PIN) ? "HIGH" : "LOW");
    
    // Test 2: Coba akses direktori root
    Serial.println("üìÅ Testing root directory access...");
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(50);
    
    File root = SD.open("/");
    if (root) {
        Serial.println("‚úÖ Root directory accessible");
        root.close();
    } else {
        Serial.println("‚ùå Root directory NOT accessible");
    }
    
    // Test 3: Cek keberadaan file CSV
    Serial.println("üìã Checking CSV files...");
    Serial.print("   SOCi2.csv: ");
    Serial.println(SD.exists("/SOCi2.csv") ? "EXISTS" : "MISSING");
    Serial.print("   BMS.csv: ");
    Serial.println(SD.exists("/BMS.csv") ? "EXISTS" : "MISSING");
    Serial.print("   Energi.csv: ");
    Serial.println(SD.exists("/Energi.csv") ? "EXISTS" : "MISSING");
    
    // Test 4: Coba tulis file test
    Serial.println("‚úç  Testing write capability...");
    File testFile = SD.open("/test.txt", FILE_WRITE);
    if (testFile) {
        testFile.println("SD Test - " + String(millis()));
        testFile.flush();
        testFile.close();
        Serial.println("‚úÖ Write test SUCCESS");
        SD.remove("/test.txt");  // Hapus file test
    } else {
        Serial.println("‚ùå Write test FAILED");
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    // Test 5: Panggil fungsi check
    Serial.println("üîç Testing checkAndReinitializeSD() function...");
    bool result = checkAndReinitializeSD();
    Serial.print("   Result: ");
    Serial.println(result ? "SUCCESS" : "FAILED");
    
    Serial.println("=================== DEBUG COMPLETE ===================\n");
}

// ===== FUNGSI TIMEREF FILE MANAGEMENT =====
void initializeTimeRef() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    // Cek apakah file timeref.txt sudah ada
    if (SD.exists("/timeref.txt")) {
        Serial.println("üìÖ [TIMEREF] Found existing timeref.txt, loading...");
        loadTimeRefFromSD();
    } else {
        Serial.println("üìÖ [TIMEREF] No timeref.txt found, will create on first timestamp");
        timeRefAvailable = false;
        globalTimeRef = 0;
        globalTimeRefBaseMillis = 0;
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

bool loadTimeRefFromSD() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    File timeRefFile = SD.open("/timeref.txt", FILE_READ);
    if (!timeRefFile) {
        Serial.println("‚ùå [TIMEREF] Failed to open timeref.txt for reading");
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    String line = timeRefFile.readStringUntil('\n');
    line.trim();
    timeRefFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    if (line.length() > 0) {
        globalTimeRef = line.toInt();
        globalTimeRefBaseMillis = millis();
        timeRefAvailable = true;
        
        Serial.print("‚úÖ [TIMEREF] Loaded timestamp: ");
        Serial.print(globalTimeRef);
        Serial.print(" at millis: ");
        Serial.println(globalTimeRefBaseMillis);
        return true;
    } else {
        Serial.println("‚ùå [TIMEREF] Invalid timeref.txt content");
        return false;
    }
}

bool saveTimeRefToSD(unsigned long timestamp) {
    if (!sdCardAvailable) {
        Serial.println("‚ùå [TIMEREF] SD card not available, cannot save timeref");
        return false;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    File timeRefFile = SD.open("/timeref.txt", FILE_WRITE);
    if (!timeRefFile) {
        Serial.println("‚ùå [TIMEREF] Failed to open timeref.txt for writing");
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    // Truncate file dan tulis timestamp baru
    timeRefFile.seek(0);
    timeRefFile.println(timestamp);
    timeRefFile.flush();
    timeRefFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    Serial.print("üíæ [TIMEREF] Saved timestamp: ");
    Serial.println(timestamp);
    return true;
}

void updateTimeRef(unsigned long newTimestamp) {
    // Update timestamp referensi global
    globalTimeRef = newTimestamp;
    globalTimeRefBaseMillis = millis();
    timeRefAvailable = true;
    lastTimeRefUpdate = millis();
    
    // Reset offline mode jika sedang aktif dan mendapat timestamp baru dari ESP32
    if (isOfflineMode) {
        isOfflineMode = false;
        Serial.println("üì∂ [TIMEREF] Online mode restored with fresh timestamp from ESP32");
    }
    
    // Simpan ke SD card
    saveTimeRefToSD(newTimestamp);
    
    Serial.print("üïê [TIMEREF] Updated global timeref to: ");
    Serial.print(globalTimeRef);
    Serial.print(" (base millis: ");
    Serial.print(globalTimeRefBaseMillis);
    Serial.print(") - Mode: ");
    Serial.println(isOfflineMode ? "OFFLINE" : "ONLINE");
}

unsigned long getCurrentTimestamp() {
    // Enhanced offline detection dengan tambahan timestamp sync
    bool espDataTimeout = espDataReceived && (millis() - lastESP32Time) >= periodESP;
    bool timestampSyncTimeout = (millis() - lastTimestampSync) >= 180000;  // 3 menit untuk timestamp sync
    bool espOffline = !espDataReceived && espDataTimeout && timestampSyncTimeout;
    
    if (!timeRefAvailable) {
        // FALLBACK MECHANISM - prioritas:
        // 1. ESP32 timestamp jika tersedia dan valid
        // 2. Millis/1000 + base offset
        
        if (espTimestamp > 1000000 && espDataReceived && !espOffline) {
            return espTimestamp;
        } else {
            return 1700000000 + (millis() / 1000);
        }
    }
    
    // === OFFLINE MODE DETECTION & AUTO INCREMENT ===
    if (espOffline && !isOfflineMode) {
        // Masuk offline mode - inisialisasi
        isOfflineMode = true;
        lastOfflineTimestamp = globalTimeRef;
        lastOfflineMillis = millis();
        Serial.println("üì¥ [OFFLINE] Mode activated");
        Serial.print("üïê [OFFLINE] Starting timestamp: ");
        Serial.println(lastOfflineTimestamp);
        
        // Check jika baru saja dapat timestamp sync
        if ((millis() - lastTimestampSync) < 120000) {  // 2 menit grace period
            Serial.println("‚è∞ [OFFLINE] Recent timestamp sync detected - using fresh timeref");
        }
    } else if (!espOffline && isOfflineMode) {
        // Keluar offline mode - kembali online
        isOfflineMode = false;
        Serial.println("üì∂ [ONLINE] Mode restored");
    }
    
    if (isOfflineMode) {
        // === OFFLINE MODE: AUTO INCREMENT SETIAP 10 DETIK ===
        unsigned long currentMillis = millis();
        unsigned long elapsedMillis = currentMillis - lastOfflineMillis;
        
        // Hitung berapa kali sudah lewat 60 detik
        unsigned long incrementCount = elapsedMillis / offlineIncrementInterval;
        
        if (incrementCount > 0) {
            // Update timestamp dan save ke timeref
            lastOfflineTimestamp += (incrementCount * 60);  // +60 detik per increment
            lastOfflineMillis = currentMillis - (elapsedMillis % offlineIncrementInterval);
            
            // UPDATE GLOBAL TIMEREF DENGAN TIMESTAMP OFFLINE BARU
            globalTimeRef = lastOfflineTimestamp;
            globalTimeRefBaseMillis = currentMillis;
            
            // SIMPAN KE SD CARD
            saveTimeRefToSD(lastOfflineTimestamp);
            
            Serial.print("‚è∞ [OFFLINE] Auto increment: ");
            Serial.print(lastOfflineTimestamp);
            Serial.print(" (+");
            Serial.print(incrementCount * 60);
            Serial.println("s)");
        }
        
        return lastOfflineTimestamp;
    } else {
        // === ONLINE MODE: KALKULASI REAL-TIME DARI TIMEREF ===
        unsigned long currentMillis = millis();
        
        // Handle millis overflow (reset setelah ~49 hari)
        if (currentMillis < globalTimeRefBaseMillis) {
            Serial.println("‚ö† [TIMEREF] Millis overflow detected, recalibrating...");
            globalTimeRefBaseMillis = currentMillis;
            saveTimeRefToSD(globalTimeRef);
        }
        
        unsigned long elapsedSeconds = (currentMillis - globalTimeRefBaseMillis) / 1000;
        unsigned long currentTimestamp = globalTimeRef + elapsedSeconds;
        
        return currentTimestamp;
    }
}

String getFormattedTimestampFromRef() {
    if (!timeRefAvailable) {
        return "NO_TIMEREF";
    }
    
    unsigned long timestamp = getCurrentTimestamp();
    
    // Simple formatting (akan lebih baik jika ada library time)
    // Format: UNIX_TIMESTAMP untuk sekarang
    return String(timestamp);
}

void debugTimeRef() {
    Serial.println("\n=================== TIMEREF DEBUG ===================");
    Serial.print("TimeRef Available: "); Serial.println(timeRefAvailable ? "YES" : "NO");
    Serial.print("Global TimeRef: "); Serial.println(globalTimeRef);
    Serial.print("Base Millis: "); Serial.println(globalTimeRefBaseMillis);
    Serial.print("Current Millis: "); Serial.println(millis());
    Serial.print("Current Timestamp: "); Serial.println(getCurrentTimestamp());
    Serial.print("Last Update: "); Serial.print(millis() - lastTimeRefUpdate); Serial.println(" ms ago");
    
    // TAMBAHAN: Debug offline mode
    Serial.print("Offline Mode: "); Serial.println(isOfflineMode ? "YES" : "NO");
    Serial.print("ESP Data Received: "); Serial.println(espDataReceived ? "YES" : "NO");
    Serial.print("ESP Timestamp: "); Serial.println(espTimestamp);
    Serial.print("Last ESP32 Time: "); Serial.print(millis() - lastESP32Time); Serial.println(" ms ago");
    
    // TAMBAHAN: Debug timestamp sync
    Serial.print("Fresh Timestamp: "); Serial.println(freshTimestampReceived ? "YES" : "NO");
    Serial.print("Last Sync Time: "); 
    if (lastTimestampSync > 0) {
        Serial.print(millis() - lastTimestampSync); Serial.println(" ms ago");
    } else {
        Serial.println("Never");
    }
    Serial.print("Last Sync Value: "); Serial.println(lastTimestampValue);
    
    if (isOfflineMode) {
        Serial.print("Last Offline Timestamp: "); Serial.println(lastOfflineTimestamp);
        Serial.print("Last Offline Millis: "); Serial.println(lastOfflineMillis);
        Serial.print("Next increment in: "); 
        unsigned long nextIncrement = offlineIncrementInterval - ((millis() - lastOfflineMillis) % offlineIncrementInterval);
        Serial.print(nextIncrement); Serial.println(" ms");
    }
    
    // Test read timeref.txt
    digitalWrite(SPI1_NSS_PIN, LOW);
    if (SD.exists("/timeref.txt")) {
        File timeRefFile = SD.open("/timeref.txt", FILE_READ);
        if (timeRefFile) {
            Serial.print("TimeRef File Content: ");
            String content = timeRefFile.readStringUntil('\n');
            Serial.println(content);
            timeRefFile.close();
        }
    } else {
        Serial.println("TimeRef File: NOT EXISTS");
    }
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    Serial.println("=================== TIMEREF DEBUG END ===================\n");
}

// Fungsi untuk generate data offline ketika ESP32 tidak tersedia
void generateOfflineData() {
    if (!isOfflineMode) return;
    
    Serial.println("üìù === GENERATING OFFLINE DATA ===");
    
    // Generate dummy data record untuk offline mode (gunakan DataRecord yang sudah ada)
    DataRecord offlineData;
    offlineData.no = count + 1;
    strcpy(offlineData.waktu, waktu);
    offlineData.timestamp = getCurrentTimestamp();
    
    // Data untuk SOCi2.csv - gunakan nilai terakhir atau dummy
    offlineData.soci2_v_pv = PZEMVoltagePanel > 0 ? PZEMVoltagePanel : 0.0;
    offlineData.soci2_i_pv = PZEMCurrentPanel > 0 ? PZEMCurrentPanel : 0.0;
    offlineData.soci2_p_pv = PZEMPowerPanel > 0 ? PZEMPowerPanel : 0.0;
    offlineData.soci2_e_pv = PZEMEnergyPanel > 0 ? PZEMEnergyPanel : 0.0;
    offlineData.soci2_v_batt = PZEMVoltageBattery > 0 ? PZEMVoltageBattery : 48.0;
    offlineData.soci2_i_batt = PZEMCurrentBattery > 0 ? PZEMCurrentBattery : 0.0;
    offlineData.soci2_p_batt = PZEMPowerBattery > 0 ? PZEMPowerBattery : 0.0;
    offlineData.soci2_e_batt = PZEMEnergyBattery > 0 ? PZEMEnergyBattery : 0.0;
    offlineData.soci2_soc = SOCo > 0 ? SOCo : 50.0;  // Use calculated SOC or default 50%
    
    // Data untuk BMS.csv - gunakan data lokal atau default
    offlineData.bms_v1 = v1 > 0 ? v1 : 12.0;
    offlineData.bms_v2 = v2 > 0 ? v2 : 12.0;
    offlineData.bms_v3 = v3 > 0 ? v3 : 12.0;
    offlineData.bms_v4 = v4 > 0 ? v4 : 12.0;
    offlineData.bms_total_v = total_voltage > 0 ? total_voltage : 48.0;
    offlineData.bms_soc = soc > 0 ? soc : SOCo;
    
    // Data untuk Energi.csv - tandai sebagai offline data
    offlineData.energi_p_batt = PZEMPowerBattery > 0 ? PZEMPowerBattery : 0.0;
    offlineData.energi_e_batt = PZEMEnergyBattery > 0 ? PZEMEnergyBattery : 0.0;
    offlineData.energi_soc = offlineData.soci2_soc;
    offlineData.energi_plts_p = PLTSPower > 0 ? PLTSPower : 0.0;
    offlineData.energi_plts_e = PLTSEnergy > 0 ? PLTSEnergy : 0.0;
    offlineData.energi_grid_p = GridPower > 0 ? GridPower : 0.0;
    offlineData.energi_grid_e = GridEnergy > 0 ? GridEnergy : 0.0;
    offlineData.energi_lux = -1.0;      // Indicate offline data (no ESP32)
    offlineData.energi_temp1 = -999.0;  // Indicate no sensor data
    offlineData.energi_temp2 = -999.0;  // Indicate no sensor data
    
    // Bitmask penulisan: semua file perlu ditulis
    offlineData.pendingWrites = 7;  // 1=SOCi2, 2=BMS, 4=Energi
    
    // Add to FIFO buffer
    if (!isFIFOFull()) {
        addToFIFO(offlineData);
        count++;
        
        Serial.print("üì¶ Offline data added to buffer. Count: "); Serial.println(fifoCount);
        Serial.print("üïê Timestamp: "); Serial.println(offlineData.timestamp);
        Serial.print("üîã Voltage: "); Serial.print(offlineData.bms_total_v, 2); Serial.println("V");
        Serial.print("üìä SOC: "); Serial.print(offlineData.bms_soc, 1); Serial.println("%");
        Serial.println("‚ö† ESP32 Data: OFFLINE (Lux: -1, Temp: -999)");
        
    } else {
        Serial.println("‚ö†Ô∏è  Buffer full! Writing to SD first...");
        handleWriteStateMachine();  // Process write state machine
        
        // Try again after buffer processing
        if (!isFIFOFull()) {
            addToFIFO(offlineData);
            count++;
            Serial.println("üì¶ Offline data added after buffer processing");
        } else {
            Serial.println("‚ùå Buffer still full after processing - data lost");
        }
    }
    
    Serial.println("=================================");
}

void postTransmission() {
  delay(3);
  digitalWrite(MAX485_RE, 0);
  digitalWrite(MAX485_DE, 0);
}

void readPZEMDC(ModbusMaster &node, float &voltage, float &current, float &power, float &energy) {
    while (Serial2.available()) Serial2.read(); // Bersihkan buffer serial
    delay(100); // Beri waktu switching RS485
    uint8_t result = node.readInputRegisters(0x0000, 6);
    if (result == node.ku8MBSuccess) {
        uint32_t tempdouble = 0x00000000;
        voltage = node.getResponseBuffer(0x0000) / 100.0;
        current = node.getResponseBuffer(0x0001) / 100.0;
        tempdouble = (node.getResponseBuffer(0x0003) << 16) + node.getResponseBuffer(0x0002);
        power = tempdouble / 10.0;
        tempdouble = (node.getResponseBuffer(0x0005) << 16) + node.getResponseBuffer(0x0004);
        energy = tempdouble;
    }
}

void readPZEMAC(ModbusMaster &node, float &voltageAC, float &currentAC, float &powerAC, float &energyAC, float &frequencyAC, float &powerFactorAC) {
    while (Serial2.available()) Serial2.read(); // Bersihkan buffer serial
    delay(100); // Beri waktu switching RS485
    uint8_t result = node.readInputRegisters(0x0000, 9);
    if (result == node.ku8MBSuccess) {
        uint32_t tempdouble = 0x00000000;
        voltageAC = node.getResponseBuffer(0x0000) / 10.0;
        tempdouble = (node.getResponseBuffer(0x0002) << 16) + node.getResponseBuffer(0x0001);
        currentAC = tempdouble / 1000.00;
        tempdouble = (node.getResponseBuffer(0x0004) << 16) + node.getResponseBuffer(0x0003);
        powerAC = tempdouble / 10.0;
        tempdouble = (node.getResponseBuffer(0x0006) << 16) + node.getResponseBuffer(0x0005);
        energyAC = tempdouble;
        frequencyAC = node.getResponseBuffer(0x0007) / 10.0;
        powerFactorAC = node.getResponseBuffer(0x0008) / 100.0;
    }
}

void readPZEMData() {
    readPZEMDC(nodePanel, PZEMVoltagePanel, PZEMCurrentPanel, PZEMPowerPanel, PZEMEnergyPanel);
    Serial.print("‚ö° PZEM Panel: ");
    Serial.print(PZEMVoltagePanel, 1); Serial.print("V ");
    Serial.print(PZEMCurrentPanel, 1); Serial.print("A ");
    Serial.print(PZEMPowerPanel, 0); Serial.println("W");
    
    delay(200);  // Kurangi dari 500ms menjadi 200ms

    readPZEMDC(nodeBattery, PZEMVoltageBattery, PZEMCurrentBattery, PZEMPowerBattery, PZEMEnergyBattery);
    Serial.print("üîã PZEM Batt: ");
    Serial.print(PZEMVoltageBattery, 1); Serial.print("V ");
    Serial.print(PZEMCurrentBattery, 1); Serial.print("A ");
    Serial.print(PZEMPowerBattery, 0); Serial.println("W");
    
    delay(200);  // Kurangi dari 500ms menjadi 200ms

    readPZEMAC(nodeAC, voltageAC, currentAC, powerAC, energyAC, frequencyAC, powerFactorAC);
    if (isPLTS) {
        PLTSVoltage = voltageAC;
        PLTSCurrent = currentAC;
        PLTSPower = powerAC;
        PLTSEnergy = energyAC;
        PLTSHz = frequencyAC;
        PLTSPf = powerFactorAC;
        Serial.print("‚òÄ PLTS: ");
        Serial.print(PLTSPower, 0); Serial.println("W");
    } else {
        GridVoltage = voltageAC;
        GridCurrent = currentAC;
        GridPower = powerAC;
        GridEnergy = energyAC;
        GridHz = frequencyAC;
        GridPf = powerFactorAC;
        Serial.print("üåê Grid: ");
        Serial.print(GridPower, 0); Serial.println("W");
    }
    delay(200);  // Kurangi dari 500ms menjadi 200ms
}

void readINA219Data() {
    if (!ina219Available) {
        INA219Voltage = 0;
        INA219Current = 0;
        return;
    }
    
    ShuntVoltage = ina219.getShuntVoltage_mV();
    INA219Voltage = ina219.getBusVoltage_V();
    INA219Current = ina219.getCurrent_mA() / 1000.0;
    
    Serial.print("üîå INA219: ");
    Serial.print(INA219Voltage, 2); Serial.print("V ");
    Serial.print(INA219Current, 2); Serial.println("A");
}

// ===== FUNGSI FIFO BUFFER =====
void addToFIFO(DataRecord data) {
    if (fifoCount < FIFO_SIZE) {
        fifoBuffer[fifoTail] = data;
        fifoTail = (fifoTail + 1) % FIFO_SIZE;
        fifoCount++;
        Serial.print("üì¶ [FIFO] Data ditambahkan. Total: ");
        Serial.print(fifoCount);
        Serial.println("/");
        Serial.println(FIFO_SIZE);
    } else {
        Serial.println("‚ö† [FIFO] Buffer penuh! Data ditolak.");
    }
}

DataRecord getFromFIFO() {
    DataRecord data;
    if (fifoCount > 0) {
        data = fifoBuffer[fifoHead];
        fifoHead = (fifoHead + 1) % FIFO_SIZE;
        fifoCount--;
        return data;
    }
    return data;
}

bool isFIFOEmpty() {
    return fifoCount == 0;
}

int getFIFOCount() {
    return fifoCount;
}

// Tambahan fungsi yang diperlukan untuk main loop
bool isFIFOFull() {
    return fifoCount >= FIFO_SIZE;
}

// Fungsi untuk write semua buffer ke SD secara batch
void writeAllFromBuffer() {
    Serial.println("üîÑ [WRITE_ALL] Starting write all buffers to SD...");
    
    // Force state machine to process all pending writes
    int attempts = 0;
    while (!isFIFOEmpty() && attempts < 20) {  // Limit attempts to avoid infinite loop
        handleWriteStateMachine();
        delay(50);  // Small delay between state transitions
        attempts++;
    }
    
    // Start new write cycle if buffer not empty
    if (!isFIFOEmpty() && currentWriteState == WRITE_IDLE) {
        currentWriteState = WRITE_SOCI2;
        writeStateTimer = millis();
        Serial.println("üîÑ [WRITE_ALL] Triggered new write cycle");
    }
    
    Serial.println("‚úÖ [WRITE_ALL] Write all completed");
}

// ===== FUNGSI BARU: HANDLE TIMESTAMP SYNC TERPISAH =====
void handleTimestampSync(String data) {
    // Format: TIMESTAMP_SYNC,timestamp,status
    int comma1 = data.indexOf(',');
    int comma2 = data.lastIndexOf(',');
    
    if (comma1 > 0 && comma2 > comma1) {
        String timestampStr = data.substring(comma1 + 1, comma2);
        String statusStr = data.substring(comma2 + 1);
        
        unsigned long newTimestamp = timestampStr.toInt();
        bool isNTP = (statusStr == "NTP");
        
        Serial.print("‚è∞ [TIMESTAMP_SYNC] Received: ");
        Serial.print(newTimestamp);
        Serial.print(" (");
        Serial.print(statusStr);
        Serial.println(")");
        
        if (newTimestamp > 1000000) {  // Valid timestamp
            // UPDATE TIMEREF SEGERA jika timestamp baru atau lebih tinggi
            if (newTimestamp > globalTimeRef || !timeRefAvailable) {
                updateTimeRef(newTimestamp);
                freshTimestampReceived = true;
                lastTimestampSync = millis();
                lastTimestampValue = newTimestamp;
                
                Serial.print("‚úÖ [TIMESTAMP_SYNC] TimeRef updated to: ");
                Serial.println(newTimestamp);
                
                // RESET OFFLINE MODE jika dapat fresh timestamp
                if (isOfflineMode) {
                    isOfflineMode = false;
                    Serial.println("üì∂ [TIMESTAMP_SYNC] Offline mode reset by fresh timestamp");
                }
            } else {
                // Update sync time even if timestamp not newer
                lastTimestampSync = millis();
                Serial.println("üîÑ [TIMESTAMP_SYNC] Sync received (not newer)");
            }
        } else {
            Serial.println("‚ùå [TIMESTAMP_SYNC] Invalid timestamp value");
        }
    } else {
        Serial.print("‚ùå [TIMESTAMP_SYNC] Parse error: ");
        Serial.println(data);
    }
}

// ===== FUNGSI MENERIMA DATA DARI ESP32 (ENHANCED) =====
void receiveESP32Data() {
    if (Serial3.available()) {
        String receivedData = Serial3.readStringUntil('\n');
        receivedData.trim();
        
        Serial.print("üì° [ESP32] Raw data: ");
        Serial.println(receivedData);
        
        // === HANDLE TIMESTAMP SYNC TERPISAH ===
        if (receivedData.startsWith("TIMESTAMP_SYNC,")) {
            handleTimestampSync(receivedData);
            return;  // Exit early, jangan proses sebagai data sensor
        }
        
        // === HANDLE DATA SENSOR LENGKAP (6 field format) ===
        // Format baru: timestamp,lux,temp1,temp2,voltage,soc (6 field)
        int commaIndex1 = receivedData.indexOf(',');                    // timestamp|lux
        int commaIndex2 = receivedData.indexOf(',', commaIndex1 + 1);   // lux|temp1
        int commaIndex3 = receivedData.indexOf(',', commaIndex2 + 1);   // temp1|temp2
        int commaIndex4 = receivedData.indexOf(',', commaIndex3 + 1);   // temp2|voltage
        int commaIndex5 = receivedData.lastIndexOf(',');                // voltage|soc
        
        if (commaIndex1 > 0 && commaIndex2 > commaIndex1 && commaIndex3 > commaIndex2 && 
            commaIndex4 > commaIndex3 && commaIndex5 > commaIndex4) {
            
            // Parse 6 field data
            String timestampStr = receivedData.substring(0, commaIndex1);
            String luxStr = receivedData.substring(commaIndex1 + 1, commaIndex2);
            String temp1Str = receivedData.substring(commaIndex2 + 1, commaIndex3);
            String temp2Str = receivedData.substring(commaIndex3 + 1, commaIndex4);
            String voltageStr = receivedData.substring(commaIndex4 + 1, commaIndex5);
            String socStr = receivedData.substring(commaIndex5 + 1);
            
            // Convert to numbers
            espTimestamp = timestampStr.toInt();
            espLux = luxStr.toFloat();
            espTemp1 = temp1Str.toFloat();
            espTemp2 = temp2Str.toFloat();
            espVoltage = voltageStr.toFloat();  // BMS Voltage dari ESP32
            espSOC = socStr.toFloat();          // BMS SOC dari ESP32
            
            espDataReceived = true;
            lastESP32Time = millis();
            
            // UPDATE TIMEREF JIKA TIMESTAMP VALID DAN LEBIH BARU
            if (espTimestamp > 1000000 && espTimestamp > globalTimeRef) {
                if (!timeRefAvailable || (millis() - lastTimeRefUpdate) >= timeRefUpdateInterval) {
                    updateTimeRef(espTimestamp);
                }
            }
            
            Serial.print("‚úÖ [ESP32] PARSED - Timestamp: ");
            Serial.print(espTimestamp);
            Serial.print(" | Lux: ");
            Serial.print(espLux, 1);
            Serial.print(" | Temp1: ");
            Serial.print(espTemp1, 1);
            Serial.print(" | Temp2: ");
            Serial.print(espTemp2, 1);
            Serial.print(" | Voltage: ");
            Serial.print(espVoltage, 2);
            Serial.print("V | SOC: ");
            Serial.print(espSOC, 1);
            Serial.println("%");
            
        } else {
            // Fallback untuk format lama 4 field: timestamp,lux,temp1,temp2
            int oldComma1 = receivedData.indexOf(',');
            int oldComma2 = receivedData.indexOf(',', oldComma1 + 1);
            int oldComma3 = receivedData.lastIndexOf(',');
            
            if (oldComma1 > 0 && oldComma2 > oldComma1 && oldComma3 > oldComma2 && 
                receivedData.indexOf(',', oldComma3 + 1) == -1) {
                // 4 field format
                espTimestamp = receivedData.substring(0, oldComma1).toInt();
                espLux = receivedData.substring(oldComma1 + 1, oldComma2).toFloat();
                espTemp1 = receivedData.substring(oldComma2 + 1, oldComma3).toFloat();
                espTemp2 = receivedData.substring(oldComma3 + 1).toFloat();
                espVoltage = 0.0;  // Default value
                espSOC = 0.0;      // Default value
                
                espDataReceived = true;
                lastESP32Time = millis();
                
                Serial.print("‚úÖ [ESP32] 4-field format - Timestamp: ");
                Serial.print(espTimestamp);
                Serial.print(" | Lux: ");
                Serial.print(espLux, 1);
                Serial.print(" | Temp1: ");
                Serial.print(espTemp1, 1);
                Serial.print(" | Temp2: ");
                Serial.print(espTemp2, 1);
                Serial.println(" | BMS: N/A");
            } else {
                // Parsing gagal
                Serial.print("‚ùå [ESP32] PARSING FAILED for: ");
                Serial.println(receivedData);
                Serial.print("   Comma positions: ");
                Serial.print(commaIndex1); Serial.print(", ");
                Serial.print(commaIndex2); Serial.print(", ");
                Serial.print(commaIndex3); Serial.print(", ");
                Serial.print(commaIndex4); Serial.print(", ");
                Serial.println(commaIndex5);
            }
        }
    }
    
    // Check timeout
    currentMillisESP = millis();
    if (espDataReceived && (currentMillisESP - lastESP32Time) >= periodESP) {
        Serial.println("‚è± [ESP32] Timeout: Data tidak diperbarui dalam 5 menit");
        espDataReceived = false;
    }
}

// ===== FUNGSI MEMBUAT DATA LENGKAP UNTUK BUFFER =====
void prepareCompleteData() {
    if (!espDataReceived) {
        Serial.println("‚ö† [BUFFER] Menunggu data ESP32...");
        return;
    }
    
    DataRecord newData;
    newData.no = count;
    strcpy(newData.waktu, waktu);
    
    // GUNAKAN TIMESTAMP DARI TIMEREF SEBAGAI SUMBER UTAMA
    newData.timestamp = getCurrentTimestamp();
    
    // Data untuk SOCi2.csv (GUNAKAN DATA REAL + ESP32 BMS)
    newData.soci2_v_pv = PZEMVoltagePanel;     // Voltage Panel dari PZEM
    newData.soci2_i_pv = PZEMCurrentPanel;     // Current Panel dari PZEM
    newData.soci2_p_pv = PZEMPowerPanel;       // Power Panel dari PZEM
    newData.soci2_e_pv = PZEMEnergyPanel;      // Energy Panel dari PZEM
    newData.soci2_v_batt = PZEMVoltageBattery; // Voltage Battery dari PZEM
    newData.soci2_i_batt = PZEMCurrentBattery; // Current Battery dari PZEM
    newData.soci2_p_batt = PZEMPowerBattery;   // Power Battery dari PZEM
    newData.soci2_e_batt = PZEMEnergyBattery;  // Energy Battery dari PZEM
    
    // SOC: Prioritas ESP32 BMS jika tersedia, fallback ke perhitungan lokal
    if (espSOC > 0.0 && espSOC <= 100.0) {
        newData.soci2_soc = espSOC;  // Gunakan SOC dari ESP32 BMS
        Serial.print("üìä Using ESP32 BMS SOC: ");
        Serial.print(espSOC, 1);
        Serial.println("%");
    } else {
        newData.soci2_soc = SOCo;    // Fallback ke perhitungan STM32
        Serial.print("üìä Using STM32 calculated SOC: ");
        Serial.print(SOCo, 1);
        Serial.println("%");
    }
    
    // Data untuk BMS.csv (PRIORITAS ESP32 BMS DATA)
    if (espVoltage > 0.0) {
        // Gunakan data BMS dari ESP32
        newData.bms_v1 = espVoltage / 4.0;         // Estimasi per cell
        newData.bms_v2 = espVoltage / 4.0;
        newData.bms_v3 = espVoltage / 4.0;
        newData.bms_v4 = espVoltage / 4.0;
        newData.bms_total_v = espVoltage;          // Total voltage dari ESP32 BMS
        newData.bms_soc = espSOC;                  // SOC dari ESP32 BMS
        
        Serial.print("üîã Using ESP32 BMS data - Voltage: ");
        Serial.print(espVoltage, 2);
        Serial.print("V, SOC: ");
        Serial.print(espSOC, 1);
        Serial.println("%");
    } else {
        // Fallback ke data lokal atau dummy
        newData.bms_v1 = v1 > 0 ? v1 : 12.0;
        newData.bms_v2 = v2 > 0 ? v2 : 12.0;
        newData.bms_v3 = v3 > 0 ? v3 : 12.0;
        newData.bms_v4 = v4 > 0 ? v4 : 12.0;
        newData.bms_total_v = total_voltage > 0 ? total_voltage : 48.0;
        newData.bms_soc = soc > 0 ? soc : SOCo;
        
        Serial.println("üîã Using local/calculated BMS data (ESP32 BMS not available)");
    }
    
    // Data untuk Energi.csv (REAL DATA dari sensor dan ESP32)
    newData.energi_p_batt = PZEMPowerBattery;
    newData.energi_e_batt = PZEMEnergyBattery;
    newData.energi_soc = newData.soci2_soc;  // Konsisten dengan SOC yang dipilih
    newData.energi_plts_p = PLTSPower;
    newData.energi_plts_e = PLTSEnergy;
    newData.energi_grid_p = GridPower;
    newData.energi_grid_e = GridEnergy;
    newData.energi_lux = espLux;       // Data dari ESP32
    newData.energi_temp1 = espTemp1;   // Data dari ESP32
    newData.energi_temp2 = espTemp2;   // Data dari ESP32
    
    // Bitmask penulisan: 1=SOCi2, 2=BMS, 4=Energi
    newData.pendingWrites = 7;  // Semua file perlu ditulis
    
    addToFIFO(newData);
    espDataReceived = false;
    
    Serial.print("üìù [BUFFER] Data ditambahkan! Timestamp: ");
    Serial.print(newData.timestamp);
    Serial.print(" | ESP32‚ÜíSTM32: Lux: ");
    Serial.print(newData.energi_lux, 1);
    Serial.print(", Temp1: ");
    Serial.print(newData.energi_temp1, 1);
    Serial.print("¬∞C, Temp2: ");
    Serial.print(newData.energi_temp2, 1);
    Serial.print("¬∞C, BMS V: ");
    Serial.print(newData.bms_total_v, 2);
    Serial.print("V, SOC: ");
    Serial.print(newData.bms_soc, 1);
    Serial.println("%");
}

// ===== FUNGSI MENULIS DATA KE SOCi2.csv DARI BUFFER =====
void writeSOCi2FromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Cek SD card sebelum menulis, tapi jangan blocking jika gagal
    Serial.println("üîç [SOCi2] Checking SD card before write...");
    bool sdReady = checkAndReinitializeSD();
    
    if (!sdReady) {
        Serial.println("‚ùå [SOCi2] SD Card tidak tersedia, skip penulisan (data tetap di buffer)");
        return;  // Data tetap di buffer untuk dicoba lagi nanti
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);  // Stabilisasi SPI
    
    // Tulis data yang memiliki flag SOCi2
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 1) {  // Check bit 0
            // Try multiple times to open file
            File file;
            bool fileOpened = false;
            
            for (int openAttempt = 1; openAttempt <= 3; openAttempt++) {
                file = SD.open("/SOCi2.csv", FILE_WRITE);
                if (file) {
                    fileOpened = true;
                    break;
                } else {
                    Serial.print("‚ùå [SOCi2] File open attempt ");
                    Serial.print(openAttempt);
                    Serial.println("/3 failed");
                    delay(100);  // Short delay between attempts
                }
            }
            
            if (fileOpened) {
                file.print(data.no); file.print(", ");
                file.print(data.waktu); file.print(", ");
                file.print(data.timestamp); file.print(", ");
                file.print(interval); file.print(", ");
                file.print(data.soci2_v_pv, 2); file.print(", ");
                file.print(data.soci2_i_pv, 3); file.print(", ");
                file.print(data.soci2_p_pv, 1); file.print(", ");
                file.print(data.soci2_e_pv, 0); file.print(", ");
                file.print(data.soci2_v_batt, 2); file.print(", ");
                file.print(data.soci2_i_batt, 3); file.print(", ");
                file.print(data.soci2_p_batt, 1); file.print(", ");
                file.print(data.soci2_e_batt, 0); file.print(", ");
                file.print(data.soci2_soc, 2); file.println();
                file.flush();  // Force write ke SD card
                file.close();
                
                Serial.print("‚úç  [SOCi2] Data written - No: ");
                Serial.print(data.no);
                Serial.print(" | Timestamp: ");
                Serial.print(data.timestamp);
                Serial.print(" | V_pv: ");
                Serial.print(data.soci2_v_pv, 2);
                Serial.print("V | SOC: ");
                Serial.print(data.soci2_soc, 1);
                Serial.println("%");
                
                data.pendingWrites &= ~1;  // Clear bit 0
                lastWriteTime = millis();   // Update last write time
            } else {
                Serial.println("‚ùå [SOCi2] Failed to open file - marking SD as unavailable");
                // Mark SD sebagai tidak tersedia tanpa recovery berulang
                sdCardAvailable = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return;  // Exit dan biarkan data di buffer untuk dicoba lagi nanti
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE BMS.csv DARI BUFFER =====
void writeBMSFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Selalu cek SD card sebelum menulis
    if (!checkAndReinitializeSD()) {
        Serial.println("‚ùå [BMS] SD Card tidak tersedia, skip penulisan");
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Tulis data yang memiliki flag BMS
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 2) {  // Check bit 1
            File file = SD.open("/BMS.csv", FILE_WRITE);
            if (file) {
                file.print(data.no); file.print(", ");
                file.print(data.waktu); file.print(", ");
                file.print(data.timestamp); file.print(", ");
                file.print(data.bms_v1, 2); file.print(", ");
                file.print(data.bms_v2, 2); file.print(", ");
                file.print(data.bms_v3, 2); file.print(", ");
                file.print(data.bms_v4, 2); file.print(", ");
                file.print(data.bms_total_v, 2); file.print(", ");
                file.print(data.bms_soc, 1); file.println();
                file.close();
                
                Serial.print("‚úç  [BMS] Data written - No: ");
                Serial.print(data.no);
                Serial.print(" | V1: ");
                Serial.print(data.bms_v1, 2);
                Serial.print("V | Total: ");
                Serial.print(data.bms_total_v, 2);
                Serial.println("V");
                
                data.pendingWrites &= ~2;  // Clear bit 1
                lastWriteTime = millis();   // Update last write time
            } else {
                Serial.println("‚ùå [BMS] Failed to open file for writing");
                // Coba cek dan reinit SD card jika file gagal dibuka
                Serial.println("üîÑ [BMS] Attempting SD card recovery...");
                digitalWrite(SPI1_NSS_PIN, HIGH);  // Release SPI first
                delay(200);  // Give time for SPI release
                
                if (checkAndReinitializeSD()) {
                    Serial.println("‚úÖ [BMS] SD card recovered, retrying write immediately...");
                    
                    // Reset SPI state for retry
                    digitalWrite(SPI1_NSS_PIN, LOW);
                    delay(50);  // SPI stabilization
                    
                    // RETRY WRITE SETELAH RECOVERY
                    File retryFile = SD.open("/BMS.csv", FILE_WRITE);
                    if (retryFile) {
                        retryFile.print(data.no); retryFile.print(", ");
                        retryFile.print(data.waktu); retryFile.print(", ");
                        retryFile.print(data.bms_v1, 2); retryFile.print(", ");
                        retryFile.print(data.bms_v2, 2); retryFile.print(", ");
                        retryFile.print(data.bms_v3, 2); retryFile.print(", ");
                        retryFile.print(data.bms_v4, 2); retryFile.print(", ");
                        retryFile.print(data.bms_total_v, 2); retryFile.print(", ");
                        retryFile.print(data.bms_soc, 1); retryFile.println();
                        retryFile.flush();
                        retryFile.close();
                        
                        Serial.println("üéØ [BMS] RETRY SUCCESS - Data written after recovery!");
                        data.pendingWrites &= ~2;  // Clear bit 1
                        lastWriteTime = millis();   // Update last write time
                    } else {
                        Serial.println("‚ùå [BMS] RETRY FAILED - File still not accessible");
                        // Try one more time with extended delay
                        delay(500);
                        File finalRetry = SD.open("/BMS.csv", FILE_WRITE);
                        if (finalRetry) {
                            finalRetry.print(data.no); finalRetry.print(", ");
                            finalRetry.print(data.waktu); finalRetry.print(", ");
                            finalRetry.print(data.bms_v1, 2); finalRetry.print(", ");
                            finalRetry.print(data.bms_v2, 2); finalRetry.print(", ");
                            finalRetry.print(data.bms_v3, 2); finalRetry.print(", ");
                            finalRetry.print(data.bms_v4, 2); finalRetry.print(", ");
                            finalRetry.print(data.bms_total_v, 2); finalRetry.print(", ");
                            finalRetry.print(data.bms_soc, 1); finalRetry.println();
                            finalRetry.flush();
                            finalRetry.close();
                            Serial.println("üéØ [BMS] FINAL RETRY SUCCESS!");
                            data.pendingWrites &= ~2;
                            lastWriteTime = millis();   // Update last write time
                        } else {
                            Serial.println("‚ùå [BMS] ALL RETRIES FAILED - Will try next cycle");
                        }
                    }
                } else {
                    Serial.println("‚ùå [BMS] SD card recovery failed");
                }
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE ENERGI.csv DARI BUFFER =====
void writeEnergiFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Selalu cek SD card sebelum menulis
    if (!checkAndReinitializeSD()) {
        Serial.println("‚ùå [Energi] SD Card tidak tersedia, skip penulisan");
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Tulis data yang memiliki flag Energi
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 4) {  // Check bit 2
            File file = SD.open("/Energi.csv", FILE_WRITE);
            if (file) {
                file.print(data.no); file.print(", ");
                file.print(data.waktu); file.print(", ");
                file.print(data.timestamp); file.print(", ");
                file.print(data.energi_p_batt, 1); file.print(", ");
                file.print(data.energi_e_batt, 0); file.print(", ");
                file.print(data.energi_soc, 2); file.print(", ");
                file.print(data.energi_plts_p, 1); file.print(", ");
                file.print(data.energi_plts_e, 0); file.print(", ");
                file.print(data.energi_grid_p, 1); file.print(", ");
                file.print(data.energi_grid_e, 0); file.print(", ");
                file.print(data.energi_lux, 1); file.print(", ");
                file.print(data.energi_temp1, 1); file.print(", ");
                file.print(data.energi_temp2, 1); file.println();
                file.close();
                
                Serial.print("‚úç  [Energi] Data written - No: ");
                Serial.print(data.no);
                Serial.print(" | P_Batt: ");
                Serial.print(data.energi_p_batt, 1);
                Serial.print("W | Lux: ");
                Serial.print(data.energi_lux, 1);
                Serial.println("lx");
                
                data.pendingWrites &= ~4;  // Clear bit 2
                lastWriteTime = millis();   // Update last write time
            } else {
                Serial.println("‚ùå [Energi] Failed to open file for writing");
                // Coba cek dan reinit SD card jika file gagal dibuka
                Serial.println("üîÑ [Energi] Attempting SD card recovery...");
                digitalWrite(SPI1_NSS_PIN, HIGH);  // Release SPI first
                delay(200);  // Give time for SPI release
                
                if (checkAndReinitializeSD()) {
                    Serial.println("‚úÖ [Energi] SD card recovered, retrying write immediately...");
                    
                    // Reset SPI state for retry
                    digitalWrite(SPI1_NSS_PIN, LOW);
                    delay(50);  // SPI stabilization
                    
                    // RETRY WRITE SETELAH RECOVERY
                    File retryFile = SD.open("/Energi.csv", FILE_WRITE);
                    if (retryFile) {
                        retryFile.print(data.no); retryFile.print(", ");
                        retryFile.print(data.waktu); retryFile.print(", ");
                        retryFile.print(data.energi_p_batt, 1); retryFile.print(", ");
                        retryFile.print(data.energi_e_batt, 0); retryFile.print(", ");
                        retryFile.print(data.energi_soc, 2); retryFile.print(", ");
                        retryFile.print(data.energi_plts_p, 1); retryFile.print(", ");
                        retryFile.print(data.energi_plts_e, 0); retryFile.print(", ");
                        retryFile.print(data.energi_grid_p, 1); retryFile.print(", ");
                        retryFile.print(data.energi_grid_e, 0); retryFile.print(", ");
                        retryFile.print(data.energi_lux, 1); retryFile.print(", ");
                        retryFile.print(data.energi_temp1, 1); retryFile.print(", ");
                        retryFile.print(data.energi_temp2, 1); retryFile.println();
                        retryFile.flush();
                        retryFile.close();
                        
                        Serial.println("üéØ [Energi] RETRY SUCCESS - Data written after recovery!");
                        data.pendingWrites &= ~4;  // Clear bit 2
                        lastWriteTime = millis();   // Update last write time
                    } else {
                        Serial.println("‚ùå [Energi] RETRY FAILED - File still not accessible");
                        // Try one more time with extended delay
                        delay(500);
                        File finalRetry = SD.open("/Energi.csv", FILE_WRITE);
                        if (finalRetry) {
                            finalRetry.print(data.no); finalRetry.print(", ");
                            finalRetry.print(data.waktu); finalRetry.print(", ");
                            finalRetry.print(data.energi_p_batt, 1); finalRetry.print(", ");
                            finalRetry.print(data.energi_e_batt, 0); finalRetry.print(", ");
                            finalRetry.print(data.energi_soc, 2); finalRetry.print(", ");
                            finalRetry.print(data.energi_plts_p, 1); finalRetry.print(", ");
                            finalRetry.print(data.energi_plts_e, 0); finalRetry.print(", ");
                            finalRetry.print(data.energi_grid_p, 1); finalRetry.print(", ");
                            finalRetry.print(data.energi_grid_e, 0); finalRetry.print(", ");
                            finalRetry.print(data.energi_lux, 1); finalRetry.print(", ");
                            finalRetry.print(data.energi_temp1, 1); finalRetry.print(", ");
                            finalRetry.print(data.energi_temp2, 1); finalRetry.println();
                            finalRetry.flush();
                            finalRetry.close();
                            Serial.println("üéØ [Energi] FINAL RETRY SUCCESS!");
                            data.pendingWrites &= ~4;
                            lastWriteTime = millis();   // Update last write time
                        } else {
                            Serial.println("‚ùå [Energi] ALL RETRIES FAILED - Will try next cycle");
                        }
                    }
                } else {
                    Serial.println("‚ùå [Energi] SD card recovery failed");
                }
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI CLEANUP BUFFER =====
void cleanupCompletedData() {
    while (!isFIFOEmpty()) {
        DataRecord& data = fifoBuffer[fifoHead];
        if (data.pendingWrites == 0) {
            getFromFIFO();  // Hapus data yang sudah selesai ditulis ke 3 file
            Serial.println("üóë  [FIFO] Data dihapus setelah ditulis ke semua file");
        } else {
            break;  // Hentikan jika masih ada file yang belum ditulis
        }
    }
}

// ===== STATE MACHINE UNTUK PENULISAN FILE SEKUENSIAL =====
void handleWriteStateMachine() {
    unsigned long currentTime = millis();
    
    // Jika buffer kosong, reset ke IDLE
    if (isFIFOEmpty()) {
        currentWriteState = WRITE_IDLE;
        return;
    }
    
    // Jika sudah lewat delay, lanjut ke state berikutnya
    // DELAY DIPERCEPAT UNTUK TESTING (100ms dari 500ms)
    if (currentTime - writeStateTimer >= writeStateDelay) {
        switch (currentWriteState) {
            case WRITE_IDLE:
                // Mulai penulisan dari state SOCI2
                if (!isFIFOEmpty()) {
                    currentWriteState = WRITE_SOCI2;
                    writeStateTimer = currentTime;
                    Serial.println("üîÑ [STATE] Mulai WRITE_SOCI2");
                }
                break;
                
            case WRITE_SOCI2:
                // Tulis ke SOCi2.csv
                writeSOCi2FromBuffer();
                currentWriteState = WRITE_BMS;
                writeStateTimer = currentTime;
                Serial.println("üîÑ [STATE] Lanjut ke WRITE_BMS");
                break;
                
            case WRITE_BMS:
                // Tulis ke BMS.csv
                writeBMSFromBuffer();
                currentWriteState = WRITE_ENERGI;
                writeStateTimer = currentTime;
                Serial.println("üîÑ [STATE] Lanjut ke WRITE_ENERGI");
                break;
                
            case WRITE_ENERGI:
                // Tulis ke Energi.csv
                writeEnergiFromBuffer();
                currentWriteState = WRITE_CLEANUP;
                writeStateTimer = currentTime;
                Serial.println("üîÑ [STATE] Lanjut ke WRITE_CLEANUP");
                break;
                
            case WRITE_CLEANUP:
                // Cleanup data yang sudah ditulis
                cleanupCompletedData();
                currentWriteState = WRITE_IDLE;
                writeStateTimer = currentTime;
                Serial.println("üîÑ [STATE] Kembali ke WRITE_IDLE");
                break;
        }
    }
}

// ===== FUNGSI DEBUG STATE MACHINE =====
void printWriteState() {
    const char* stateNames[] = {"IDLE", "SOCI2", "BMS", "ENERGI", "CLEANUP"};
    Serial.print("üìç [STATE] Current: ");
    Serial.print(stateNames[currentWriteState]);
    Serial.print(" | FIFO Count: ");
    Serial.print(getFIFOCount());
    Serial.print("/");
    Serial.println(FIFO_SIZE);
}

void urgent() {
    if (PZEMCurrentBattery > 10.0) {
        digitalWrite(RELAY_Batt, LOW);
        Serial.print("‚ö† OVERCURRENT: "); Serial.print(PZEMCurrentBattery); Serial.println("A > 10.0A");
    } else {
        digitalWrite(RELAY_Batt, HIGH);
    }
}

void calculateSOC() {
    deltaT = periodSOC / 3600000.0;  // 60000ms / 3600000ms = 0.0167 jam (1 menit)
    kapasitas = ((PZEMCurrentBattery * deltaT) / Ah) * 100.0;

    if (INA219Current < -0.2) { // charging
        if (previousStatus != statusbatt) count = 0;
        count++;
        SOCo += kapasitas;
        statusbatt = 1;
        Serial.println("‚¨Ü  Baterai Charging");
    } else if (INA219Current > 0.2) { // discharging
        if (previousStatus != statusbatt) count = 0;
        count++;
        SOCo -= kapasitas;
        statusbatt = 0;
        Serial.println("‚¨á  Baterai Discharging");
    }
    previousStatus = statusbatt;
    interval = (count * periodSOC)/60000;  // Konversi ke menit
    SOCo = constrain(SOCo, 0, 100);
    SOCt = static_cast<int>(SOCo);
    Serial.print("üìä SOC: "); Serial.print(SOCo, 1); Serial.println("%");
}

void ATS() {
  unsigned long now = millis();
  bool waktuAktif = (jam >= 18 || jam < 11);  // jam 18:00 s/d 05:59

  // === 1. Jika di luar jam aktif ‚Üí matikan semua relay ===
  if (!waktuAktif) {
    digitalWrite(RELAY_Inv, LOW);
    digitalWrite(RELAY_ATS_F, LOW);
    digitalWrite(RELAY_ATS_N, LOW);
    isPLTS = false;
    waitToTurnOn = false;
    Serial.println("‚õî Di luar jam aktif - Relay OFF (PLN)");
    return;
  }

  // === 2. Jika SOC < 30% ‚Üí matikan relay dan reset status ===
  if (SOCt < 30) {
    digitalWrite(RELAY_Inv, LOW);
    digitalWrite(RELAY_ATS_F, LOW);
    digitalWrite(RELAY_ATS_N, LOW);
    isPLTS = false;
    waitToTurnOn = false;
    Serial.println("üîã SOC < 30% - Relay OFF (PLN)");
    return;
  }

  // === 3. Jika SOC ‚â• 90% dan belum ON ‚Üí tunggu 5 detik ===
  if (SOCt >= 90 && !isPLTS) {
    if (!waitToTurnOn) {
      waitToTurnOn = true;
      timeToTurnOn = now;
      Serial.println("‚è≥ SOC ‚â• 90% - Tunggu 5 detik sebelum Relay ON");
    }

    if (now - timeToTurnOn >= 5000) {
      digitalWrite(RELAY_Inv, HIGH);
      digitalWrite(RELAY_ATS_F, HIGH);
      digitalWrite(RELAY_ATS_N, HIGH);
      isPLTS = true;
      waitToTurnOn = false;
      Serial.println("‚úÖ SOC ‚â• 90% stabil - Relay ON (PLTS)");
    } else {
      digitalWrite(RELAY_Inv, LOW);
      digitalWrite(RELAY_ATS_F, LOW);
      digitalWrite(RELAY_ATS_N, LOW);
    }
    return;
  }

  // === 4. SOC 30‚Äì89% ‚Üí pertahankan status sebelumnya ===
  digitalWrite(RELAY_Inv, isPLTS ? HIGH : LOW);
  digitalWrite(RELAY_ATS_F, isPLTS ? HIGH : LOW);
  digitalWrite(RELAY_ATS_N, isPLTS ? HIGH : LOW);

  Serial.print("üì∂ SOC ");
  Serial.print(SOCt);
  Serial.print("% - Relay ");
  Serial.print(isPLTS ? "NYALA ‚úÖ" : "MATI ‚ùå");
  Serial.println(" - Sumber: " + String(isPLTS ? "PLTS" : "PLN"));
}

void logtoSDcard() {
    // Siapkan data lengkap dari semua sensor dan masukkan ke buffer
    prepareCompleteData();
    
    // Trigger state machine untuk penulisan sekuensial
    if (currentWriteState == WRITE_IDLE && !isFIFOEmpty()) {
        currentWriteState = WRITE_SOCI2;
        writeStateTimer = millis();
        Serial.println("‚è± [TRIGGER] Penulisan file dimulai");
    }
    
    // Display buffer status
    Serial.print("üìä [FIFO Status] Count: ");
    Serial.print(getFIFOCount());
    Serial.print("/");
    Serial.println(FIFO_SIZE);
}

void loop() {
    currentMillisPZEM = millis();
    currentMillisSOC = millis();
    currentMillisINA = millis();
    currentMillisATS = millis();
    currentMillisSDCheck = millis();

    // ================ MAIN MONITORING CYCLE ================
    
    // 1. Check ESP32 data reception
    receiveESP32Data();
    
    // 2. Monitor system status and periodic reporting
    static unsigned long lastStatusReport = 0;
    if (millis() - lastStatusReport > 30000) { // Status report every 30 seconds
        Serial.println("\nüöÄ === SYSTEM STATUS REPORT ===");
        Serial.print("Uptime: "); Serial.print(millis()/1000); Serial.println(" seconds");
        Serial.print("ESP32 Status: "); Serial.println(espDataReceived ? "CONNECTED" : "DISCONNECTED");
        Serial.print("Data Count: "); Serial.println(count);
        Serial.print("FIFO Buffer: "); Serial.print(fifoCount); Serial.print("/"); Serial.println(FIFO_SIZE);
        Serial.print("SD Card: "); Serial.println(SD.begin(SPI1_NSS_PIN) ? "OK" : "ERROR");
        Serial.print("Mode: "); Serial.println(isOfflineMode ? "OFFLINE" : "ONLINE");
        Serial.println("============================\n");
        lastStatusReport = millis();
    }
    
    // 3. Check for data timeout and switch to offline mode
    if (espDataReceived && (millis() - lastESP32Time > periodESP)) {
        Serial.println("‚ö†Ô∏è  ESP32 timeout detected, switching to offline mode");
        espDataReceived = false;
        isOfflineMode = true;
    }
    
    // 4. Handle offline data generation
    if (isOfflineMode) {
        static unsigned long lastOfflineData = 0;
        if (millis() - lastOfflineData > 60000) { // Generate offline data every minute
            Serial.println("üìù Generating offline timestamp data");
            generateOfflineData();
            lastOfflineData = millis();
        }
    }
    
    // 5. Periodic buffer write to SD card
    static unsigned long lastPeriodicWrite = 0;
    if (millis() - lastPeriodicWrite > 300000) { // Write every 5 minutes
        Serial.println("‚è∞ Periodic buffer write to SD card");
        writeAllFromBuffer();
        lastPeriodicWrite = millis();
    }
    
    // 6. Monitor buffer overflow protection
    if (fifoCount >= FIFO_SIZE - 5) {
        Serial.println("‚ö†Ô∏è  Buffer nearly full, forcing write to SD card");
        writeAllFromBuffer();
    }
    
    // ================ END MAIN MONITORING ================

    // Command dari Serial Monitor untuk debug
    if (Serial.available()) {
        String command = Serial.readStringUntil('\n');
        command.trim();
        command.toLowerCase();
        
        if (command == "timeref") {
            debugTimeRef();
        } else if (command == "sync") {
            Serial.println("\n=================== TIMESTAMP SYNC DEBUG ===================");
            Serial.print("Fresh Timestamp Received: "); Serial.println(freshTimestampReceived ? "YES" : "NO");
            Serial.print("Last Timestamp Sync: "); 
            if (lastTimestampSync > 0) {
                Serial.print(millis() - lastTimestampSync); Serial.println(" ms ago");
            } else {
                Serial.println("Never");
            }
            Serial.print("Last Timestamp Value: "); Serial.println(lastTimestampValue);
            Serial.print("ESP Data Received: "); Serial.println(espDataReceived ? "YES" : "NO");
            Serial.print("ESP Last Time: "); 
            if (lastESP32Time > 0) {
                Serial.print(millis() - lastESP32Time); Serial.println(" ms ago");
            } else {
                Serial.println("Never");
            }
            Serial.print("Current Timestamp: "); Serial.println(getCurrentTimestamp());
            Serial.print("TimeRef Source: "); Serial.println(timeRefAvailable ? "AVAILABLE" : "FALLBACK");
            Serial.print("Offline Mode: "); Serial.println(isOfflineMode ? "YES" : "NO");
            Serial.println("=================== SYNC DEBUG END ===================\n");
        } else if (command == "offline") {
            Serial.println("\n=================== OFFLINE MODE TEST ===================");
            Serial.print("Current Mode: "); Serial.println(isOfflineMode ? "OFFLINE" : "ONLINE");
            Serial.print("ESP Data Received: "); Serial.println(espDataReceived ? "YES" : "NO");
            Serial.print("Last ESP32 Time: "); Serial.print(millis() - lastESP32Time); Serial.println(" ms ago");
            Serial.print("Timeout Threshold: "); Serial.println(periodESP);
            
            if (isOfflineMode) {
                Serial.print("Last Offline Timestamp: "); Serial.println(lastOfflineTimestamp);
                unsigned long nextIncrement = offlineIncrementInterval - ((millis() - lastOfflineMillis) % offlineIncrementInterval);
                Serial.print("Next increment in: "); Serial.print(nextIncrement); Serial.println(" ms");
            }
            Serial.println("=================== OFFLINE MODE END ===================\n");
        } else if (command == "fifo") {
            Serial.println("\nüì¶ === FIFO BUFFER STATUS ===");
            Serial.print("Count: "); Serial.print(fifoCount); Serial.print("/"); Serial.println(FIFO_SIZE);
            Serial.print("Head: "); Serial.print(fifoHead); Serial.print(" | Tail: "); Serial.println(fifoTail);
            printWriteState();
            Serial.println("========================\n");
            
        } else if (command == "esp32" || command == "espdata") {
            Serial.println("üì° === ESP32 DATA STATUS ===");
            Serial.print("Data Received: "); Serial.println(espDataReceived ? "YES" : "NO");
            Serial.print("Last Update: "); Serial.print(millis() - lastESP32Time); Serial.println(" ms ago");
            Serial.print("Timestamp: "); Serial.println(espTimestamp);
            Serial.print("Lux: "); Serial.print(espLux, 1); Serial.println(" lx");
            Serial.print("Temp1: "); Serial.print(espTemp1, 1); Serial.println("¬∞C");
            Serial.print("Temp2: "); Serial.print(espTemp2, 1); Serial.println("¬∞C");
            Serial.print("BMS Voltage: "); Serial.print(espVoltage, 2); Serial.println("V");
            Serial.print("BMS SOC: "); Serial.print(espSOC, 1); Serial.println("%");
            Serial.println("==========================");
            
        } else if (command == "bms" || command == "bmsdata") {
            Serial.println("üîã === BMS COMPARISON ===");
            Serial.println("ESP32 BMS Data:");
            Serial.print("  Voltage: "); Serial.print(espVoltage, 2); Serial.println("V");
            Serial.print("  SOC: "); Serial.print(espSOC, 1); Serial.println("%");
            Serial.println("Local BMS Data:");
            Serial.print("  V1: "); Serial.print(v1, 2); Serial.println("V");
            Serial.print("  V2: "); Serial.print(v2, 2); Serial.println("V");
            Serial.print("  V3: "); Serial.print(v3, 2); Serial.println("V");
            Serial.print("  V4: "); Serial.print(v4, 2); Serial.println("V");
            Serial.print("  Total: "); Serial.print(total_voltage, 2); Serial.println("V");
            Serial.print("  SOC: "); Serial.print(soc, 1); Serial.println("%");
            Serial.println("STM32 Calculated:");
            Serial.print("  SOC: "); Serial.print(SOCo, 1); Serial.println("%");
            Serial.println("========================");
            
        } else if (command == "checkbms" || command == "verifybms") {
            Serial.println("üîç === VERIFY BMS DATA TO SD ===");
            
            // Cek data terakhir di buffer
            if (!isFIFOEmpty()) {
                int lastIndex = (fifoTail - 1 + FIFO_SIZE) % FIFO_SIZE;
                DataRecord& lastData = fifoBuffer[lastIndex];
                
                Serial.println("üìä Last Buffer Data:");
                Serial.print("  BMS Total Voltage: "); Serial.print(lastData.bms_total_v, 2); Serial.println("V");
                Serial.print("  BMS SOC: "); Serial.print(lastData.bms_soc, 1); Serial.println("%");
                Serial.print("  SOCi2 SOC: "); Serial.print(lastData.soci2_soc, 1); Serial.println("%");
                Serial.print("  Energi SOC: "); Serial.print(lastData.energi_soc, 1); Serial.println("%");
                
                Serial.println("üì° ESP32 Source Data:");
                Serial.print("  ESP Voltage: "); Serial.print(espVoltage, 2); Serial.println("V");
                Serial.print("  ESP SOC: "); Serial.print(espSOC, 1); Serial.println("%");
                
                Serial.println("üíæ Will be written to SD as:");
                Serial.println("  SOCi2.csv ‚Üí SOC column");
                Serial.println("  BMS.csv ‚Üí Total Voltage & SOC columns");  
                Serial.println("  Energi.csv ‚Üí SOC column");
                
            } else {
                Serial.println("‚ùå No data in buffer");
            }
            
            Serial.println("================================");
            
        } else if (command == "force" || command == "forcesave") {
            Serial.println("üöÄ === FORCE SAVE TO SD ===");
            if (espDataReceived) {
                prepareCompleteData();
                Serial.println("Data prepared from ESP32 buffer");
            } else {
                Serial.println("‚ö† No ESP32 data, creating dummy data...");
                // Force create data dengan nilai terakhir
                DataRecord newData;
                newData.no = count + 1;
                strcpy(newData.waktu, waktu);
                newData.timestamp = getCurrentTimestamp();
                
                // Use last known values
                newData.soci2_v_pv = PZEMVoltagePanel;
                newData.soci2_i_pv = PZEMCurrentPanel;
                newData.soci2_p_pv = PZEMPowerPanel;
                newData.soci2_e_pv = PZEMEnergyPanel;
                newData.soci2_v_batt = PZEMVoltageBattery;
                newData.soci2_i_batt = PZEMCurrentBattery;
                newData.soci2_p_batt = PZEMPowerBattery;
                newData.soci2_e_batt = PZEMEnergyBattery;
                newData.soci2_soc = espSOC > 0 ? espSOC : SOCo;
                
                newData.bms_v1 = v1 > 0 ? v1 : 12.0;
                newData.bms_v2 = v2 > 0 ? v2 : 12.0;
                newData.bms_v3 = v3 > 0 ? v3 : 12.0;
                newData.bms_v4 = v4 > 0 ? v4 : 12.0;
                newData.bms_total_v = espVoltage > 0 ? espVoltage : total_voltage;
                newData.bms_soc = espSOC > 0 ? espSOC : soc;
                
                newData.energi_p_batt = PZEMPowerBattery;
                newData.energi_e_batt = PZEMEnergyBattery;
                newData.energi_soc = newData.soci2_soc;
                newData.energi_plts_p = PLTSPower;
                newData.energi_plts_e = PLTSEnergy;
                newData.energi_grid_p = GridPower;
                newData.energi_grid_e = GridEnergy;
                newData.energi_lux = espLux;
                newData.energi_temp1 = espTemp1;
                newData.energi_temp2 = espTemp2;
                
                newData.pendingWrites = 7;  // All files
                addToFIFO(newData);
            }
            
            // Force write semua buffer
            Serial.println("Writing all buffer to SD...");
            handleWriteStateMachine();  // Process satu cycle
            Serial.println("Force save completed");
            Serial.println("==============================");
        }
        
        else if (command == "sd" || command == "sdcard") {
            Serial.println("üíæ === SD CARD STATUS ===");
            Serial.print("SD Available: "); Serial.println(sdCardAvailable ? "YES" : "NO");
            Serial.print("Buffer Count: "); Serial.println(fifoCount);
            Serial.print("Data No: "); Serial.println(count);
            Serial.print("Last Write: "); 
            if (millis() > lastWriteTime) {
                Serial.print(millis() - lastWriteTime); Serial.println(" ms ago");
            } else {
                Serial.println("Never");
            }
            Serial.println("Files Status:");
            
            // Test file access
            digitalWrite(SPI1_NSS_PIN, LOW);
            delay(10);
            
            File testFile = SD.open("/");
            if (testFile) {
                Serial.println("SD card accessible");
                testFile.close();
            } else {
                Serial.println("SD card ERROR");
            }
            
            digitalWrite(SPI1_NSS_PIN, HIGH);
            Serial.println("===============================");
        }
        else if (command == "reset") {
            // Reset data counters
            count = 0;
            fifoCount = 0;
            lastWriteTime = 0;
            Serial.println("Data counters reset");
        }
        else if (command == "help") {
            Serial.println("Available commands:");
            Serial.println("- esp32: Show last ESP32 data");
            Serial.println("- bms: Show last BMS data");
            Serial.println("- checkbms: Compare ESP32 vs STM32 BMS");
            Serial.println("- force: Force write all buffers");
            Serial.println("- sd: Show SD card status");
            Serial.println("- timeref: Show timeref debug");
            Serial.println("- sync: Show timestamp sync debug");
            Serial.println("- offline: Show offline mode debug");
            Serial.println("- fifo: Show buffer status");
            Serial.println("- reset: Reset counters");
            Serial.println("- help: Show this help");
        }
    }
}
