#include <ModbusMaster.h>
#include <SPI.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_INA219.h>

// Pin MAX485
#define MAX485_DE      PA0
#define MAX485_RE      PA1

// Pin Relay
#define RELAY_Inv      PB15
#define RELAY_Batt     PB14
#define RELAY_ATS_N    PB13
#define RELAY_ATS_F    PB12

// SPI
#define SPI1_NSS_PIN PA4  // SPI_1 digunakan untuk komunikasi dengan SD Card

// Alamat slave untuk PZEM
static uint8_t pzemSlaveAddrPanel = 0x01;
static uint8_t pzemSlaveAddrBattery = 0x02;
static uint8_t pzemSlaveAddrAC = 0x03;

// Objek ModbusMaster
ModbusMaster nodePanel;
ModbusMaster nodeBattery;
ModbusMaster nodeAC;
Adafruit_INA219 ina219;
 
// Variabel untuk PZEM Panel
float PZEMVoltagePanel = 0.00, PZEMCurrentPanel = 0.00, PZEMPowerPanel = 0.00, PZEMEnergyPanel = 0.00;
float PVEnergyRaw = 0.00;  // Nilai mentah dari PZEM PV
float PVEnergyBaseline = 0.0;  // Baseline untuk daily reset

// Variabel untuk PZEM Baterai
float PZEMVoltageBattery = 0.00, PZEMCurrentBattery = 0.00, PZEMPowerBattery = 0.00, PZEMEnergyBattery = 0.00;
float BattEnergyRaw = 0.00;  // Nilai mentah dari PZEM Battery
float BattEnergyBaseline = 0.0;  // Baseline untuk daily reset

// Variable untuk PSEM AC
float voltageAC, currentAC, powerAC, energyAC, frequencyAC, powerFactorAC;

// Variabel untuk PZEM AC - LOAD MONITORING
// Note: Variable names use "PLTS" for backward compatibility, but these measure LOAD power/energy
float PLTSVoltage = 0.00, PLTSCurrent = 0.00, PLTSPower = 0.00, PLTSEnergy = 0, PLTSHz = 0.00, PLTSPf = 0.00;
float GridVoltage = 0.00, GridCurrent = 0.00, GridPower = 0.00, GridEnergy = 0, GridHz = 0.00, GridPf = 0.00;

// Baseline energy untuk daily reset (SEMUA PZEM pakai baseline method)
float LoadEnergyRaw = 0.0;  // Nilai mentah dari PZEM AC (Load)
float LoadEnergyBaseline = 0.0;  // Baseline untuk daily reset Load

// Variabel untuk INA219
float ShuntVoltage = 0.00, INA219Voltage = 0.00, INA219Current = 0.00;
bool ina219Available = false;  // Flag untuk track status INA219

// Initial SOC
bool soc_initialized = false;  // Global flag

// Tambahan variabel BMS
float v1 = 0.0, v2 = 0.0, v3 = 0.0, v4 = 0.0;
float total_voltage = 0.0, soc = 0.0;
float bms_temp1 = 0.0, bms_temp2 = 0.0;  // <-- BARU: temperature BMS dari ESP32
float bms_current = 0.0;  // <-- BARU: current BMS dari ESP32

// Variabel untuk menerima data ESP32
unsigned long espTimestamp = 0;
float espLux = 0.0, espTemp1 = 0.0, espTemp2 = 0.0;
float espTotalVoltage = 0.0, espTotalCurrent = 0.0, espSOC = 0.0;  // <-- UPDATE: tambah current
float espBMSTemp1 = 0.0, espBMSTemp2 = 0.0;  // <-- BARU: BMS temperature
float espCellV1 = 0.0, espCellV2 = 0.0, espCellV3 = 0.0, espCellV4 = 0.0;  // <-- BARU: Cell voltages
bool espDataReceived = false;
unsigned long lastESP32Time = 0;

// ===== VARIABEL GLOBAL TIMEREF =====
unsigned long globalTimeRef = 0;        // Timestamp referensi global
unsigned long globalTimeRefBaseMillis = 0; // Basis millis() saat timeref di-set
bool timeRefAvailable = false;           // Flag ketersediaan timeref
unsigned long lastTimeRefUpdate = 0;     // Terakhir kali timeref diupdate
const unsigned long timeRefUpdateInterval = 300000; // Update timeref setiap 5 menit

// ===== STRUKTUR DATA UNTUK FIFO BUFFER (UPDATE) =====
struct DataRecord {
    int no;
    char waktu[10];
    unsigned long timestamp;
    float pzempv_v_pv, pzempv_i_pv, pzempv_p_pv, pzempv_e_pv;
    float pzembatt_v_batt, pzembatt_i_batt, pzembatt_p_batt, pzembatt_e_batt, pzembatt_soc;
    float bms_v1, bms_v2, bms_v3, bms_v4, bms_total_v, bms_total_i, bms_soc;  // <-- UPDATE: tambah total_i
    float bms_temp1, bms_temp2;  // <-- BARU: BMS temperatures
    float energi_p_batt, energi_e_batt, energi_soc;
    float load_plts_p, load_plts_e;
    float energi_lux, energi_temp1, energi_temp2;
    int pendingWrites;
};

// FIFO Buffer (ukuran 20 slot)
#define FIFO_SIZE 20
DataRecord fifoBuffer[FIFO_SIZE];
int fifoHead = 0;
int fifoTail = 0;
int fifoCount = 0;

// Timer untuk ESP32
unsigned long startMillisESP;
unsigned long currentMillisESP;
const unsigned long periodESP = 60000;  // 10 detik timeout (disesuaikan dengan testing)

// State Machine untuk penulisan file sekuensial
enum WriteState {
    WRITE_IDLE = 0,
    WRITE_PZEMPV = 1,
    WRITE_PZEMBATT=2,
    WRITE_BMS = 3,
    WRITE_LOAD = 4,
    WRITE_CLEANUP = 5
};
WriteState currentWriteState = WRITE_IDLE;

// Timer untuk state machine penulisan
unsigned long writeStateTimer = 0;
const unsigned long writeStateDelay = 100;  // 100ms delay antar penulisan file (dipercepat untuk testing)

// Pengolahan Data
int previousStatus = -1;  // Inisialisasi dengan nilai tidak valid
int count = 0, SOCt = 0, Ah = 100, interval = 0;
float deltaT = 0.0, SOCo = 0.0, kapasitas = 0.0;
char waktu[10];

// Status Alat Terkini
int statusbatt = 0, statuscsv = 0;

// Variable callback
const char* hari = "";
const char* bulan = "";
int tanggal, tahun, jam, menit, detik;

// Variabel global yang dibutuhkan
bool isPLTS = false;                  // true = relay ON (pakai PLTS)
bool waitToTurnOn = false;           // status delay sebelum ON
unsigned long timeToTurnOn = 0;      // waktu mulai delay

//Timer untuk Pembaharuan Data
unsigned long startMillisPZEM;
unsigned long currentMillisPZEM;
const unsigned long periodPZEM = 60000; // 10 detik (1 cycle untuk testing)

//Timer untuk INA219
unsigned long startMillisINA;
unsigned long currentMillisINA;
const unsigned long periodINA = 60000; // 10 detik (sinkron dengan PZEM)

//Timer untuk ATS
unsigned long startMillisATS;
unsigned long currentMillisATS;
const unsigned long periodATS = 60000; // 10 detik (sinkron dengan PZEM)

//Timer untuk SD CARD (TESTING: 10 detik per cycle - 1 cycle saja)
unsigned long startMillisSOC;
unsigned long currentMillisSOC;
const unsigned long periodSOC = 60000;  // 1 menit untuk 1 cycle testing

//Timer untuk SD Card Check (setiap 30 detik)
unsigned long startMillisSDCheck;
unsigned long currentMillisSDCheck;
const unsigned long periodSDCheck = 60000;  // 30 detik

// Timer untuk Reset Energi PZEM (setiap jam 00:00 WIB)
unsigned long lastEnergyResetTimestamp = 0;  // Timestamp terakhir reset energi
bool energyResetInitialized = false;  // Flag untuk inisialisasi pertama kali
int lastResetDay = -1;  // Hari terakhir reset dilakukan (-1 = belum pernah)
const int TIMEZONE_OFFSET = 7 * 3600;  // WIB = UTC+7 (dalam detik)

// Manual Control Mode - untuk mencegah auto-switching relay
bool manualControlMode = false;  // Flag untuk manual control via web
// Manual control aktif terus sampai command 'automode' diterima

// Status SD Card
bool sdCardAvailable = true;
bool testMode = false; // Skip PZEM reads when true (for testing)
bool sdCardWasRemoved = false;  // Flag untuk track jika SD card pernah dicabut
bool isRecursiveCheck = false;  // Proteksi terhadap rekursi berlebihan

void setup() {
  // Serial Monitor
  Serial.begin(9600);
  while (!Serial);
  
  // Debug: Pastikan serial terhubung
  delay(2000);
  Serial.println("\n\n========== STARTUP ==========");
  Serial.println("STM32 System Starting...");

  // Komunikasi Antar Perangkat
  Serial2.begin(9600, SERIAL_8N2); // Untuk komunikasi PZEM
  Serial3.begin(9600);  // Untuk komunikasi dengan ESP32 (9600 baud)
  delay(500);

  pinMode(SPI1_NSS_PIN, OUTPUT);
  digitalWrite(SPI1_NSS_PIN, HIGH);

  // Inisialisasi SD Card
  digitalWrite(SPI1_NSS_PIN, LOW);
  if (!SD.begin(SPI1_NSS_PIN)) {
    while (1);
  }
  digitalWrite(SPI1_NSS_PIN, HIGH);
  delay(500);

  // Konfigurasi MAX485
  pinMode(MAX485_RE, OUTPUT);
  pinMode(MAX485_DE, OUTPUT);
  digitalWrite(MAX485_RE, 0);
  digitalWrite(MAX485_DE, 0);

  // Konfigurasi Relay
  pinMode(RELAY_ATS_F, OUTPUT);
  pinMode(RELAY_Inv, OUTPUT);
  pinMode(RELAY_Batt, OUTPUT);
  pinMode(RELAY_ATS_N, OUTPUT);

  digitalWrite(RELAY_ATS_F, HIGH);
  digitalWrite(RELAY_Inv, HIGH);
  digitalWrite(RELAY_Batt, HIGH);
  digitalWrite(RELAY_ATS_N, HIGH);

  // Inisialisasi Modbus
  nodePanel.begin(pzemSlaveAddrPanel, Serial2);
  nodePanel.preTransmission(preTransmission);
  nodePanel.postTransmission(postTransmission);

  nodeBattery.begin(pzemSlaveAddrBattery, Serial2);
  nodeBattery.preTransmission(preTransmission);
  nodeBattery.postTransmission(postTransmission);

  nodeAC.begin(pzemSlaveAddrAC, Serial2);
  nodeAC.preTransmission(preTransmission);
  nodeAC.postTransmission(postTransmission);

  // Inisialisasi I2C (Wire)
  Wire.begin();
  delay(500);
  
  // Inisialisasi INA219
  if (! ina219.begin())
  {
    while (1) 
    {
      delay(10);
    }
  }
  ina219.setCalibration_32V_50A();
  ina219Available = true;

  startMillisPZEM = millis();
  startMillisSOC = millis();
  startMillisESP = millis();
  startMillisINA = millis();
  startMillisATS = millis();
  startMillisSDCheck = millis();
  
  // Inisialisasi file CSV di SD Card
  Serial.println("\nInitializing CSV files on SD Card...");
  initializeCSVFiles();
  
  // Inisialisasi TimeRef
  Serial.println("\nInitializing TimeRef system...");
  initializeTimeRef();
  
  // Load baselines dari SD card
  Serial.println("\nLoading energy baselines from SD...");
  loadBaselinesFromSD();
  
  Serial.println("========== STARTUP COMPLETE ==========\n");
}

void preTransmission() {
  digitalWrite(MAX485_RE, 1);
  digitalWrite(MAX485_DE, 1);
  delay(1);
}

// ===== FUNGSI INISIALISASI FILE CSV =====
void initializeCSVFiles() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // === Inisialisasi PZEMPV.csv ===
    if (!SD.exists("/PZEMPV.csv")) {
        File file = SD.open("/PZEMPV.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;V PV (V);I PV (A);P PV (W);E PV (Wh)");
            file.close();
            Serial.println("‚úì PZEMPV.csv created with header");
        } else {
            Serial.println("‚ùå Failed to create PZEMPV.csv");
        }
    } else {
        Serial.println("‚úì PZEMPV.csv already exists");
    }

    // === Inisialisasi PZEMBATT.csv ===
    if (!SD.exists("/PZEMBATT.csv")) {
        File file = SD.open("/PZEMBATT.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;V Batt (V);I Batt (A);P Batt (W);E Batt (Wh)");
            file.close();
            Serial.println("‚úì PZEMBATT.csv created with header");
        } else {
            Serial.println("‚ùå Failed to create PZEMBATT.csv");
        }
    } else {
        Serial.println("‚úì PZEMBATT.csv already exists");
    }
    
    // === Inisialisasi BMS.csv (UPDATE HEADER - tambah Current dan Temperature) ===
    if (!SD.exists("/BMS.csv")) {
        File file = SD.open("/BMS.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;V1 (V);V2 (V);V3 (V);V4 (V);Total Voltage (V);Total Current (A);Temp1 (C);Temp2 (C);SOC (%)");
            file.close();
            Serial.println("‚úì BMS.csv created with header (with Current and Temperature)");
        } else {
            Serial.println("‚ùå Failed to create BMS.csv");
        }
    } else {
        Serial.println("‚úì BMS.csv already exists");
    }
    
    // === Inisialisasi LOAD&ENV.csv ===
    if (!SD.exists("/LOAD.csv")) {
        File file = SD.open("/LOAD.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;PLTS Power (W);PLTS Energy (Wh);Lux (lx);Temp1 (C);Temp2 (C)");
            file.close();
            Serial.println("‚úì load.csv created with header");
        } else {
            Serial.println("‚ùå Failed to create LOAD.csv");
        }
    } else {
        Serial.println("‚úì load.csv already exists");
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
    Serial.println("üì¶ All CSV files ready!\n");
}

// ===== FUNGSI PENGECEKAN DAN REINISIALISASI SD CARD =====
bool checkAndReinitializeSD() {
    if (isRecursiveCheck) return false;
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    File root = SD.open("/");
    if (!root) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        if (!sdCardWasRemoved) sdCardWasRemoved = true;
        delay(500);
        
        for (int attempt = 1; attempt <= 3; attempt++) {
            digitalWrite(SPI1_NSS_PIN, LOW);
            delay(100);
            if (SD.begin(SPI1_NSS_PIN)) {
                File testAccess = SD.open("/PZEMPV.csv", FILE_WRITE);
                if (testAccess) {
                    testAccess.close();
                } else {
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    delay(500);
                    continue;
                }
                if (!SD.exists("/PZEMPV.csv") || !SD.exists("/BMS.csv")) {
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    initializeCSVFiles();
                }
                currentWriteState = WRITE_IDLE;
                writeStateTimer = millis();
                sdCardAvailable = true;
                sdCardWasRemoved = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return true;
            } else {
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(1000);
            }
        }
        sdCardAvailable = false;
        return false;
    } else {
        root.close();
        File testFile = SD.open("/PZEMPV.csv", FILE_WRITE);
        if (!testFile) {
            digitalWrite(SPI1_NSS_PIN, HIGH);
            if (!isRecursiveCheck) {
                isRecursiveCheck = true;
                delay(500);
                digitalWrite(SPI1_NSS_PIN, LOW);
                delay(100);
                if (SD.begin(SPI1_NSS_PIN)) {
                    File retestFile = SD.open("/PZEMPV.csv", FILE_WRITE);
                    if (retestFile) {
                        retestFile.close();
                        sdCardAvailable = true;
                        digitalWrite(SPI1_NSS_PIN, HIGH);
                        isRecursiveCheck = false;
                        return true;
                    } else {
                        sdCardAvailable = false;
                        digitalWrite(SPI1_NSS_PIN, HIGH);
                        isRecursiveCheck = false;
                        return false;
                    }
                } else {
                    sdCardAvailable = false;
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    isRecursiveCheck = false;
                    return false;
                }
            } else {
                sdCardAvailable = false;
                return false;
            }
        }
        testFile.close();
        if (sdCardWasRemoved) {
            sdCardWasRemoved = false;
            currentWriteState = WRITE_IDLE;
            writeStateTimer = millis();
        }
        isRecursiveCheck = false;
        sdCardAvailable = true;
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return true;
    }
}

// ===== FUNGSI TIMEREF FILE MANAGEMENT =====
void initializeTimeRef() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    if (SD.exists("/timeref.txt")) {
        loadTimeRefFromSD();
    } else {
        timeRefAvailable = false;
        globalTimeRef = 0;
        globalTimeRefBaseMillis = 0;
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

bool loadTimeRefFromSD() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    File timeRefFile = SD.open("/timeref.txt", FILE_READ);
    if (!timeRefFile) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    String line = timeRefFile.readStringUntil('\n');
    line.trim();
    timeRefFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    if (line.length() > 0) {
        globalTimeRef = line.toInt();
        globalTimeRefBaseMillis = millis();
        timeRefAvailable = true;
        return true;
    }
    return false;
}

bool saveTimeRefToSD(unsigned long timestamp) {
    if (!sdCardAvailable) return false;
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    File timeRefFile = SD.open("/timeref.txt", FILE_WRITE);
    if (!timeRefFile) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    timeRefFile.seek(0);
    timeRefFile.println(timestamp);
    timeRefFile.flush();
    timeRefFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    return true;
}

void updateTimeRef(unsigned long newTimestamp) {
    globalTimeRef = newTimestamp;
    globalTimeRefBaseMillis = millis();
    timeRefAvailable = true;
    lastTimeRefUpdate = millis();
    saveTimeRefToSD(newTimestamp);
}

// ===== FUNGSI KONTROL RELAY VIA COMMAND DARI ESP32 =====
void handleRelayCommand(String command) {
    command.trim();
    
    // Jangan set manual mode untuk GET_RELAY_STATUS (hanya query)
    if (command != "GET_RELAY_STATUS") {
        manualControlMode = true;
        Serial.println("[CONTROL] >>> MANUAL MODE ACTIVATED by: " + command);
    }
    
    if (command == "RELAY_INV_ON") {
        digitalWrite(RELAY_Inv, HIGH);
        Serial.println("[RELAY] Inverter ON (Manual)");
        Serial3.println("RELAY_INV_STATUS:ON");
    }
    else if (command == "RELAY_INV_OFF") {
        digitalWrite(RELAY_Inv, LOW);
        Serial.println("[RELAY] Inverter OFF (Manual)");
        Serial3.println("RELAY_INV_STATUS:OFF");
    }
    else if (command == "RELAY_BATT_ON") {
        digitalWrite(RELAY_Batt, HIGH);
        Serial.println("[RELAY] Battery ON (Manual)");
        Serial3.println("RELAY_BATT_STATUS:ON");
    }
    else if (command == "RELAY_BATT_OFF") {
        digitalWrite(RELAY_Batt, LOW);
        Serial.println("[RELAY] Battery OFF (Manual)");
        Serial3.println("RELAY_BATT_STATUS:OFF");
    }
    else if (command == "RELAY_ATS_N_ON") {
        digitalWrite(RELAY_ATS_N, HIGH);
        Serial.println("[RELAY] ATS Normal ON (Manual)");
        Serial3.println("RELAY_ATS_N_STATUS:ON");
    }
    else if (command == "RELAY_ATS_N_OFF") {
        digitalWrite(RELAY_ATS_N, LOW);
        Serial.println("[RELAY] ATS Normal OFF (Manual)");
        Serial3.println("RELAY_ATS_N_STATUS:OFF");
    }
    else if (command == "RELAY_ATS_F_ON") {
        digitalWrite(RELAY_ATS_F, HIGH);
        Serial.println("[RELAY] ATS Force ON (Manual)");
        Serial3.println("RELAY_ATS_F_STATUS:ON");
    }
    else if (command == "RELAY_ATS_F_OFF") {
        digitalWrite(RELAY_ATS_F, LOW);
        Serial.println("[RELAY] ATS Force OFF (Manual)");
        Serial3.println("RELAY_ATS_F_STATUS:OFF");
    }
    else if (command == "GET_RELAY_STATUS") {
        String s = "RELAY_STATUS:INV=";
        s += digitalRead(RELAY_Inv) ? "ON," : "OFF,";
        s += "BATT=";
        s += digitalRead(RELAY_Batt) ? "ON," : "OFF,";
        s += "ATS_N=";
        s += digitalRead(RELAY_ATS_N) ? "ON," : "OFF,";
        s += "ATS_F=";
        s += digitalRead(RELAY_ATS_F) ? "ON" : "OFF";
        Serial3.println(s);
    }
    else if (command == "DISABLE_AUTO_CONTROL") {
        manualControlMode = true;
        Serial.println("[CONTROL] Auto-control DISABLED (Manual mode active)");
        Serial3.println("AUTO_CONTROL:DISABLED");
    }
    else if (command == "ENABLE_AUTO_CONTROL") {
        manualControlMode = false;
        Serial.println("[CONTROL] Auto-control ENABLED");
        Serial3.println("AUTO_CONTROL:ENABLED");
    }
}

// ===== FUNGSI HELPER UNTUK WAKTU =====
// Mendapatkan jam saat ini (0-23) dari Unix timestamp dengan timezone WIB
int getCurrentHour() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;  // Konversi ke WIB
    return (localTs % 86400) / 3600;  // 86400 detik per hari, 3600 detik per jam
}

// Mendapatkan menit saat ini (0-59)
int getCurrentMinute() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;
    return (localTs % 3600) / 60;
}

// Mendapatkan hari dalam tahun dari Unix timestamp (untuk tracking reset harian)
int getDayOfYear() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;  // Konversi ke WIB
    return (localTs / 86400);  // Jumlah hari sejak epoch
}

unsigned long getCurrentTimestamp() {
    if (!timeRefAvailable) {
        // FALLBACK MECHANISM - prioritas:
        // 1. ESP32 timestamp jika tersedia dan valid
        // 2. Millis/1000 + base offset
        
        if (espTimestamp > 1000000 && espDataReceived) {
            // Gunakan timestamp ESP32 jika valid dan data baru diterima
            return espTimestamp;
        } else {
            // Fallback ke millis dengan base offset 1700000000 (sekitar 2023)
            return 1700000000 + (millis() / 1000);
        }
    }
    
    // Hitung timestamp saat ini berdasarkan timeref + elapsed millis
    unsigned long currentMillis = millis();
    
    // Handle millis overflow (reset setelah ~49 hari)
    if (currentMillis < globalTimeRefBaseMillis) {
        globalTimeRefBaseMillis = currentMillis;
        saveTimeRefToSD(globalTimeRef);
    }
    
    unsigned long elapsedSeconds = (currentMillis - globalTimeRefBaseMillis) / 1000;
    unsigned long currentTimestamp = globalTimeRef + elapsedSeconds;
    
    return currentTimestamp;
}

String getFormattedTimestampFromRef() {
    if (!timeRefAvailable) {
        return "NO_TIMEREF";
    }
    
    unsigned long timestamp = getCurrentTimestamp();
    
    // Simple formatting (akan lebih baik jika ada library time)
    // Format: UNIX_TIMESTAMP untuk sekarang
    return String(timestamp);
}

void postTransmission() {
  delay(3);
  digitalWrite(MAX485_RE, 0);
  digitalWrite(MAX485_DE, 0);
}

// ===== FUNGSI SAVE/LOAD BASELINE KE SD CARD =====
void saveBaselinesToSD() {
    if (!sdCardAvailable) {
        Serial.println("[BASELINE] SD Card not available, cannot save");
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    // Hapus file lama jika ada
    if (SD.exists("/baseline.txt")) {
        SD.remove("/baseline.txt");
        Serial.println("[BASELINE] Old file removed");
    }
    
    // Buat file baru
    File baselineFile = SD.open("/baseline.txt", FILE_WRITE);
    if (baselineFile) {
        baselineFile.println(PVEnergyBaseline, 0);
        baselineFile.println(BattEnergyBaseline, 0);
        baselineFile.println(LoadEnergyBaseline, 0);
        baselineFile.flush();
        baselineFile.close();
        Serial.println("[BASELINE] Saved to SD card:");
        Serial.print("  PV: "); Serial.println(PVEnergyBaseline, 0);
        Serial.print("  Batt: "); Serial.println(BattEnergyBaseline, 0);
        Serial.print("  Load: "); Serial.println(LoadEnergyBaseline, 0);
    } else {
        Serial.println("[BASELINE] ERROR: Failed to create file!");
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

bool loadBaselinesFromSD() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    if (!SD.exists("/baseline.txt")) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        Serial.println("[BASELINE] File not found, using 0.0");
        PVEnergyBaseline = 0.0;
        BattEnergyBaseline = 0.0;
        LoadEnergyBaseline = 0.0;
        return false;
    }
    
    File baselineFile = SD.open("/baseline.txt", FILE_READ);
    if (!baselineFile) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    String line1 = baselineFile.readStringUntil('\n');
    String line2 = baselineFile.readStringUntil('\n');
    String line3 = baselineFile.readStringUntil('\n');
    baselineFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    PVEnergyBaseline = line1.toFloat();
    BattEnergyBaseline = line2.toFloat();
    LoadEnergyBaseline = line3.toFloat();
    
    Serial.println("[BASELINE] Loaded from SD:");
    Serial.print("  PV: "); Serial.println(PVEnergyBaseline, 0);
    Serial.print("  Batt: "); Serial.println(BattEnergyBaseline, 0);
    Serial.print("  Load: "); Serial.println(LoadEnergyBaseline, 0);
    
    return true;
}

void resetAllPZEMEnergy() {
    Serial.println("========== RESET ALL PZEM (BASELINE METHOD) ==========");
    delay(200); 
    
    Serial.println("\n[1/3] Setting PV baseline...");
    readPZEMDC(nodePanel, PZEMVoltagePanel, PZEMCurrentPanel, PZEMPowerPanel, PVEnergyRaw);
    PVEnergyBaseline = PVEnergyRaw;
    Serial.print("   PV Baseline: ");
    Serial.print(PVEnergyBaseline, 0);
    Serial.println(" Wh");
    delay(300); 
    
    Serial.println("\n[2/3] Setting Battery baseline...");
    readPZEMDC(nodeBattery, PZEMVoltageBattery, PZEMCurrentBattery, PZEMPowerBattery, BattEnergyRaw);
    BattEnergyBaseline = BattEnergyRaw;
    Serial.print("   Batt Baseline: ");
    Serial.print(BattEnergyBaseline, 0);
    Serial.println(" Wh");
    delay(300); 
    
    Serial.println("\n[3/3] Setting Load baseline...");
    readPZEMAC(nodeAC, voltageAC, currentAC, powerAC, LoadEnergyRaw, frequencyAC, powerFactorAC);
    LoadEnergyBaseline = LoadEnergyRaw;
    Serial.print("   Load Baseline: ");
    Serial.print(LoadEnergyBaseline, 0);
    Serial.println(" Wh");
    
    // Save baselines to SD card
    saveBaselinesToSD();
    
    lastEnergyResetTimestamp = getCurrentTimestamp();
    lastResetDay = getDayOfYear();
    
    Serial.println("\n========== RESET COMPLETE ==========\n");
}

void checkAndResetEnergy() {
    // Gunakan timeRef jika tersedia, fallback ke espTimestamp
    int currentHour = -1;
    int currentDay = -1;
    int currentMinute = -1;
    
    if (timeRefAvailable) {
        currentHour = getCurrentHour();
        currentMinute = getCurrentMinute();
        currentDay = getDayOfYear();
    } else if (espTimestamp > 1000000) {
        // Fallback: gunakan espTimestamp langsung
        unsigned long localTs = espTimestamp + TIMEZONE_OFFSET;
        currentHour = (localTs % 86400) / 3600;
        currentMinute = (localTs % 3600) / 60;
        currentDay = (localTs / 86400);
        Serial.println("[RESET] Using espTimestamp fallback for time");
    } else {
        // Tidak ada sumber waktu sama sekali
        return;
    }
    
    if (!energyResetInitialized) {
        if (timeRefAvailable) {
            lastEnergyResetTimestamp = getCurrentTimestamp();
        } else {
            lastEnergyResetTimestamp = espTimestamp;
        }
        lastResetDay = currentDay;
        energyResetInitialized = true;
        Serial.print("[RESET] Initialized. Hour: "); Serial.print(currentHour);
        Serial.print(":"); Serial.print(currentMinute);
        Serial.print(" Day: "); Serial.println(currentDay);
        return;
    }
    
    // Reset energi jika:
    // 1. Jam 15:00 WIB - TESTING MODE
    // 2. Belum reset hari ini
    if (currentHour == 15 && currentMinute >= 0 && currentDay != lastResetDay) {
        Serial.println("[RESET] Reset time detected (15:00 WIB) - TEST MODE");
        Serial.print("   Previous reset day: "); Serial.println(lastResetDay);
        Serial.print("   Current day: "); Serial.println(currentDay);
        Serial.print("   Time: "); Serial.print(currentHour); Serial.print(":"); Serial.println(currentMinute);
        
        resetAllPZEMEnergy();
    }
}

void readPZEMDC(ModbusMaster &node, float &voltage, float &current, float &power, float &energy) {
    while (Serial2.available()) Serial2.read(); // Bersihkan buffer serial
    delay(100); // Beri waktu switching RS485
    uint8_t result = node.readInputRegisters(0x0000, 6);
    if (result == node.ku8MBSuccess) {
        uint32_t tempdouble = 0x00000000;
        voltage = node.getResponseBuffer(0x0000) / 100.0;
        current = node.getResponseBuffer(0x0001) / 100.0;
        tempdouble = (node.getResponseBuffer(0x0003) << 16) + node.getResponseBuffer(0x0002);
        power = tempdouble / 10.0;
        tempdouble = (node.getResponseBuffer(0x0005) << 16) + node.getResponseBuffer(0x0004);
        energy = tempdouble;
    } else {
        Serial.print("[PZEM DC] Read FAILED! Error code: ");
        Serial.println(result, HEX);
        // Keep previous values, don't reset to 0
    }
}

void readPZEMAC(ModbusMaster &node, float &voltageAC, float &currentAC, float &powerAC, float &energyAC, float &frequencyAC, float &powerFactorAC) {
    while (Serial2.available()) Serial2.read(); // Bersihkan buffer serial
    delay(100); // Beri waktu switching RS485
    uint8_t result = node.readInputRegisters(0x0000, 9);
    if (result == node.ku8MBSuccess) {
        uint32_t tempdouble = 0x00000000;
        voltageAC = node.getResponseBuffer(0x0000) / 10.0;
        tempdouble = (node.getResponseBuffer(0x0002) << 16) + node.getResponseBuffer(0x0001);
        currentAC = tempdouble / 1000.00;
        tempdouble = (node.getResponseBuffer(0x0004) << 16) + node.getResponseBuffer(0x0003);
        powerAC = tempdouble / 10.0;
        tempdouble = (node.getResponseBuffer(0x0006) << 16) + node.getResponseBuffer(0x0005);
        energyAC = tempdouble;
        frequencyAC = node.getResponseBuffer(0x0007) / 10.0;
        powerFactorAC = node.getResponseBuffer(0x0008) / 100.0;
    } else {
        Serial.print("[PZEM AC] Read FAILED! Error code: ");
        Serial.println(result, HEX);
        // Keep previous values, don't reset to 0
    }
}

void readPZEMData() {
    Serial.println("\n========== READING PZEM DATA ==========");
    
    if (testMode) {
        Serial.println("[TEST MODE] Skipping PZEM reads - using manual values");
        // Calculate daily values from raw - baseline
        PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
        if (PZEMEnergyPanel < 0) PZEMEnergyPanel = 0;
        PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
        if (PZEMEnergyBattery < 0) PZEMEnergyBattery = 0;
        PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
        if (PLTSEnergy < 0) PLTSEnergy = 0;
        
        Serial.print("PV Raw:"); Serial.print(PVEnergyRaw, 0);
        Serial.print(" Base:"); Serial.print(PVEnergyBaseline, 0);
        Serial.print(" Daily:"); Serial.println(PZEMEnergyPanel, 0);
        
        Serial.print("Batt Raw:"); Serial.print(BattEnergyRaw, 0);
        Serial.print(" Base:"); Serial.print(BattEnergyBaseline, 0);
        Serial.print(" Daily:"); Serial.println(PZEMEnergyBattery, 0);
        
        Serial.print("Load Raw:"); Serial.print(LoadEnergyRaw, 0);
        Serial.print(" Base:"); Serial.print(LoadEnergyBaseline, 0);
        Serial.print(" Daily:"); Serial.println(PLTSEnergy, 0);
        return;
    }
    
    // Read PV with baseline calculation
    readPZEMDC(nodePanel, PZEMVoltagePanel, PZEMCurrentPanel, PZEMPowerPanel, PVEnergyRaw);
    PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
    if (PZEMEnergyPanel < 0) PZEMEnergyPanel = 0;
    
    Serial.print("PV: ");
    Serial.print(PZEMVoltagePanel, 1); Serial.print("V ");
    Serial.print(PZEMCurrentPanel, 1); Serial.print("A ");
    Serial.print(PZEMPowerPanel, 0); Serial.print("W ");
    Serial.print("Raw:"); Serial.print(PVEnergyRaw, 0);
    Serial.print(" Base:"); Serial.print(PVEnergyBaseline, 0);
    Serial.print(" E:"); Serial.print(PZEMEnergyPanel, 0); Serial.println("Wh");
    
    delay(200);

    // Read Battery with baseline calculation
    readPZEMDC(nodeBattery, PZEMVoltageBattery, PZEMCurrentBattery, PZEMPowerBattery, BattEnergyRaw);
    PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
    if (PZEMEnergyBattery < 0) PZEMEnergyBattery = 0;
    
    Serial.print("Batt: ");
    Serial.print(PZEMVoltageBattery, 1); Serial.print("V ");
    Serial.print(PZEMCurrentBattery, 1); Serial.print("A ");
    Serial.print(PZEMPowerBattery, 0); Serial.print("W ");
    Serial.print("Raw:"); Serial.print(BattEnergyRaw, 0);
    Serial.print(" Base:"); Serial.print(BattEnergyBaseline, 0);
    Serial.print(" E:"); Serial.print(PZEMEnergyBattery, 0); Serial.println("Wh");
    
    delay(200);

    // Read Load with baseline calculation
    Serial.println("Reading PZEM AC (LOAD monitoring)...");
    readPZEMAC(nodeAC, voltageAC, currentAC, powerAC, LoadEnergyRaw, frequencyAC, powerFactorAC);
    PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
    if (PLTSEnergy < 0) PLTSEnergy = 0;
    
    PLTSVoltage = voltageAC;
    PLTSCurrent = currentAC;
    PLTSPower = powerAC;
    PLTSHz = frequencyAC;
    PLTSPf = powerFactorAC;
    
    Serial.print("LOAD: ");
    Serial.print(PLTSVoltage, 1); Serial.print("V ");
    Serial.print(PLTSCurrent, 3); Serial.print("A ");
    Serial.print(PLTSPower, 0); Serial.print("W ");
    Serial.print(PLTSHz, 1); Serial.print("Hz PF:"); Serial.print(PLTSPf, 2);
    Serial.print(" E:"); Serial.print(PLTSEnergy, 0); Serial.println("Wh");
    Serial.println("======================================\n");

    delay(200);
}

void readINA219Data() {
    ShuntVoltage = ina219.getShuntVoltage_mV();
    INA219Voltage = ina219.getBusVoltage_V();
    INA219Current = ina219.getCurrent_mA() / 1000.0;
    Serial.println("INA219 Batt:");
    Serial.print("Shunt Voltage: "); Serial.print(ShuntVoltage); Serial.print(" mV   ");
    Serial.print("INA219 Voltage: "); Serial.print(INA219Voltage, 2); Serial.print(" V   ");
    Serial.print("INA219 Current: "); Serial.print(INA219Current, 3); Serial.println(" A");
}

void sendDataToESP() {
    // 15 field: PV(4) + Battery(4) + INA219(3) + LOAD(2) + AC PZEM(2)
    // Field 12-13: LOAD Power & Energy (measured by PZEM AC - displayed as "Load" in web interface)
    String data = String(PZEMVoltagePanel) + "," + String(PZEMCurrentPanel) + "," + String(PZEMPowerPanel) + "," + String(PZEMEnergyPanel) + "," +
                  String(PZEMVoltageBattery) + "," + String(PZEMCurrentBattery) + "," + String(PZEMPowerBattery) + "," + String(PZEMEnergyBattery) + "," +
                  String(INA219Voltage) + "," + String(INA219Current) + "," + String(ShuntVoltage) + "," +
                  String(PLTSPower) + "," + String(PLTSEnergy) + "," +  // These are LOAD measurements
                  String(voltageAC) + "," + String(currentAC) + "\n";  // Field 14-15: AC Voltage & Current
    Serial3.println(data); // Kirim ke ESP32
    Serial.print("Data to ESP (15 fields): ");
    Serial.println(data);  // Debug di serial monitor STM
    Serial.print("LOAD: "); Serial.print(PLTSPower); Serial.print("W, ");
    Serial.print(PLTSEnergy); Serial.println("Wh");
}

void addToFIFO(DataRecord data) {
    if (fifoCount < FIFO_SIZE) {
        fifoBuffer[fifoTail] = data;
        fifoTail = (fifoTail + 1) % FIFO_SIZE;
        fifoCount++;
    }
}

DataRecord getFromFIFO() {
    DataRecord data;
    if (fifoCount > 0) {
        data = fifoBuffer[fifoHead];
        fifoHead = (fifoHead + 1) % FIFO_SIZE;
        fifoCount--;
        return data;
    }
    return data;
}

bool isFIFOEmpty() {
    return fifoCount == 0;
}

int getFIFOCount() {
    return fifoCount;
}

// ===== FUNGSI MENERIMA DATA DARI ESP32 =====
void receiveESP32Data() {
    if (Serial3.available()) {
        String receivedData = Serial3.readStringUntil('\n');
        receivedData.trim();
        
        // 1. Relay Command
        if (receivedData.startsWith("RELAY_")) {
            handleRelayCommand(receivedData);
            return;
        }
        
        // 2. Timestamp Sync
        if (receivedData.startsWith("TIMESTAMP_SYNC,")) {
            int firstComma = receivedData.indexOf(',');
            int secondComma = receivedData.indexOf(',', firstComma + 1);
            
            if (firstComma > 0 && secondComma > 0) {
                String timestampStr = receivedData.substring(firstComma + 1, secondComma);
                unsigned long newTimestamp = strtoul(timestampStr.c_str(), NULL, 10);
                
                if (newTimestamp > 1000000 && newTimestamp > globalTimeRef) {
                    updateTimeRef(newTimestamp);
                }
            }
            return;
        }
        
        // 3. Sensor Data (13 fields)
        int commaCount = 0;
        for (int i = 0; i < receivedData.length(); i++) {
            if (receivedData.charAt(i) == ',') commaCount++;
        }
        
        if (commaCount == 12) {
            int pos[13];
            pos[0] = 0;
            int commaIndex = 1;
            
            for (int i = 0; i < receivedData.length() && commaIndex < 13; i++) {
                if (receivedData.charAt(i) == ',') {
                    pos[commaIndex++] = i;
                }
            }
            
            if (commaIndex == 13) {
                String timestampStr = receivedData.substring(pos[0], pos[1]);
                espTimestamp = strtoul(timestampStr.c_str(), NULL, 10);
                Serial.print(timestampStr);
                Serial.print("' -> parsed: ");
                Serial.println(espTimestamp);
                
                espLux = receivedData.substring(pos[1] + 1, pos[2]).toFloat();
                espTemp1 = receivedData.substring(pos[2] + 1, pos[3]).toFloat();
                espTemp2 = receivedData.substring(pos[3] + 1, pos[4]).toFloat();
                espTotalVoltage = receivedData.substring(pos[4] + 1, pos[5]).toFloat();
                espTotalCurrent = receivedData.substring(pos[5] + 1, pos[6]).toFloat();
                espSOC = receivedData.substring(pos[6] + 1, pos[7]).toFloat();
                espBMSTemp1 = receivedData.substring(pos[7] + 1, pos[8]).toFloat();
                espBMSTemp2 = receivedData.substring(pos[8] + 1, pos[9]).toFloat();
                espCellV1 = receivedData.substring(pos[9] + 1, pos[10]).toFloat();
                espCellV2 = receivedData.substring(pos[10] + 1, pos[11]).toFloat();
                espCellV3 = receivedData.substring(pos[11] + 1, pos[12]).toFloat();
                espCellV4 = receivedData.substring(pos[12] + 1).toFloat();
                
                espDataReceived = true;
                lastESP32Time = millis();
                
                // Validasi timestamp
                bool timestampValid = (espTimestamp > 1000000 && espTimestamp < 2147483647);
                
                Serial.println("üì° [ESP32] 13-field format detected");
                Serial.print("   ‚è∞ Timestamp: "); Serial.print(espTimestamp);
                if (timestampValid) {
                    Serial.println(" ‚úÖ VALID");
                } else {
                    Serial.print(" ‚ö†Ô∏è INVALID (expected > 1000000, got: ");
                    Serial.print(espTimestamp);
                    Serial.println(")");
                }
                
                // UPDATE TIMEREF JIKA TIMESTAMP VALID DAN LEBIH BARU
                if (timestampValid && espTimestamp > globalTimeRef) {
                    if (!timeRefAvailable || (millis() - lastTimeRefUpdate) >= timeRefUpdateInterval) {
                        Serial.print("   üîÑ Updating TimeRef: ");
                        Serial.print(globalTimeRef);
                        Serial.print(" -> ");
                        Serial.println(espTimestamp);
                        updateTimeRef(espTimestamp);
                    } else {
                        Serial.println("   ‚è≠ TimeRef skip (recently updated)");
                    }
                } else if (!timestampValid) {
                    Serial.println("   ‚ùå TimeRef NOT updated (invalid timestamp)");
                } else if (espTimestamp <= globalTimeRef) {
                    Serial.print("   ‚è™ TimeRef NOT updated (old timestamp: ");
                    Serial.print(espTimestamp);
                    Serial.print(" <= ");
                    Serial.print(globalTimeRef);
                    Serial.println(")");
                }
                Serial.print("   üå° DS18B20: Lux:"); Serial.print(espLux, 1);
                Serial.print(" T1:"); Serial.print(espTemp1, 1);
                Serial.print("¬∞C T2:"); Serial.print(espTemp2, 1); Serial.println("¬∞C");
                Serial.print("   üîã BMS: V:"); Serial.print(espTotalVoltage, 2);
                Serial.print("V I:"); Serial.print(espTotalCurrent, 2);
                Serial.print("A SOC:"); Serial.print(espSOC, 1); Serial.println("%");
                Serial.print("   üå° BMS Temp: T1:"); Serial.print(espBMSTemp1, 1);
                Serial.print("¬∞C T2:"); Serial.print(espBMSTemp2, 1); Serial.println("¬∞C");
                Serial.print("   üî¨ Cells: V1:"); Serial.print(espCellV1, 3);
                Serial.print("V V2:"); Serial.print(espCellV2, 3);
                Serial.print("V V3:"); Serial.print(espCellV3, 3);
                Serial.print("V V4:"); Serial.print(espCellV4, 3); Serial.println("V");
                
                return;  // Exit after successful parsing
            }
        }
                
        // Format lama lainnya untuk backward compatibility
        Serial.println("‚ö† [ESP32] Unknown format, trying fallback parsing...");
    }
    
    // Check timeout
    currentMillisESP = millis();
    if (espDataReceived && (currentMillisESP - lastESP32Time) >= periodESP) {
        Serial.println("‚è± [ESP32] Timeout: Data tidak diperbarui");
        espDataReceived = false;
    }
}

// ===== FUNGSI MEMBUAT DATA LENGKAP UNTUK BUFFER (UPDATE) =====
void prepareCompleteData() {
    if (!espDataReceived) {
        Serial.println("‚ö† [BUFFER] Menunggu data ESP32...");
        return;
    }
    
    DataRecord newData;
    newData.no = count;
    strcpy(newData.waktu, waktu);
    
    // GUNAKAN TIMESTAMP DARI TIMEREF SEBAGAI SUMBER UTAMA
    newData.timestamp = getCurrentTimestamp();
    
    // Data untuk PZEMPV.csv
    newData.pzempv_v_pv = PZEMVoltagePanel;
    newData.pzempv_i_pv = PZEMCurrentPanel;
    newData.pzempv_p_pv = PZEMPowerPanel;
    newData.pzempv_e_pv = PZEMEnergyPanel;
    
    // Data untuk PZEMBATT.csv
    newData.pzembatt_v_batt = PZEMVoltageBattery;
    newData.pzembatt_i_batt = PZEMCurrentBattery;
    newData.pzembatt_p_batt = PZEMPowerBattery;
    newData.pzembatt_e_batt = PZEMEnergyBattery;
    newData.pzembatt_soc = SOCo;
    
    // Data untuk BMS.csv
    newData.bms_v1 = espCellV1;
    newData.bms_v2 = espCellV2;
    newData.bms_v3 = espCellV3;
    newData.bms_v4 = espCellV4;
    newData.bms_total_v = espTotalVoltage;
    newData.bms_total_i = espTotalCurrent;
    newData.bms_temp1 = espBMSTemp1;
    newData.bms_temp2 = espBMSTemp2;
    newData.bms_soc = espSOC;
    
    // Data untuk LOAD.csv (LOAD monitoring via PZEM AC)
    newData.energi_p_batt = PZEMPowerBattery;
    newData.energi_e_batt = PZEMEnergyBattery;
    newData.energi_soc = SOCo;
    newData.load_plts_p = PLTSPower;  // This is actually LOAD power
    newData.load_plts_e = PLTSEnergy;  // This is actually LOAD energy
    newData.energi_lux = espLux;
    newData.energi_temp1 = espTemp1;
    newData.energi_temp2 = espTemp2;
    
    // Bitmask penulisan: bit 0=PZEMPV, bit 1=BMS, bit 2=LOAD, bit 3=PZEMBATT
    // Total: 1 + 2 + 4 + 8 = 15 (semua file)
    newData.pendingWrites = 15;
    
    addToFIFO(newData);
    espDataReceived = false;
    
    Serial.print("üìù [BUFFER] Data ditambahkan! Timestamp: ");
    Serial.print(newData.timestamp);
    Serial.print(" | PendingWrites: ");
    Serial.println(newData.pendingWrites);
    Serial.print("   PZEMPV: V:"); Serial.print(newData.pzempv_v_pv, 2);
    Serial.print("V | PZEMBATT: V:"); Serial.print(newData.pzembatt_v_batt, 2);
    Serial.println("V");
}

// ===== FUNGSI MENULIS DATA KE PZEMPV.csv DARI BUFFER =====
void writePZEMPVFromBuffer() {
    if (isFIFOEmpty()) return;
    bool sdReady = checkAndReinitializeSD();
    if (!sdReady) return;
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    // Tulis data yang memiliki flag PZEMPV (bit 0)
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 1) {  // Check bit 0
            File file;
            bool fileOpened = false;
            
            for (int openAttempt = 1; openAttempt <= 3; openAttempt++) {
                file = SD.open("/PZEMPV.csv", FILE_WRITE);
                if (file) {
                    fileOpened = true;
                    break;
                } else {
                    Serial.print("‚ùå [PZEMPV] File open attempt ");
                    Serial.print(openAttempt);
                    Serial.println("/3 failed");
                    delay(100);
                }
            }
            
            if (fileOpened) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.pzempv_v_pv, 2); file.print("; ");
                file.print(data.pzempv_i_pv, 3); file.print("; ");
                file.print(data.pzempv_p_pv, 1); file.print("; ");
                file.print(data.pzempv_e_pv, 0); file.println();
                file.flush();
                file.close();
                
                Serial.print("‚úç  [PZEMPV] Data written - No: ");
                Serial.print(data.no);
                Serial.print(" | V:"); Serial.print(data.pzempv_v_pv, 2);
                Serial.print("V I:"); Serial.print(data.pzempv_i_pv, 3);
                Serial.print("A P:"); Serial.print(data.pzempv_p_pv, 1);
                Serial.println("W");
                
                data.pendingWrites &= ~1;  // Clear bit 0
            } else {
                
                sdCardAvailable = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return;
            }
            break;
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE PZEMBATT.csv DARI BUFFER =====
void writePZEMBATTFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Cek SD card sebelum menulis
    
    bool sdReady = checkAndReinitializeSD();
    
    if (!sdReady) {
        
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    // Tulis data yang memiliki flag PZEMBATT (bit 3)
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 8) {  // Check bit 3 (2^3 = 8)
            File file;
            bool fileOpened = false;
            
            for (int openAttempt = 1; openAttempt <= 3; openAttempt++) {
                file = SD.open("/PZEMBATT.csv", FILE_WRITE);
                if (file) {
                    fileOpened = true;
                    break;
                } else {
                    Serial.print("‚ùå [PZEMBATT] File open attempt ");
                    Serial.print(openAttempt);
                    Serial.println("/3 failed");
                    delay(100);
                }
            }
            
            if (fileOpened) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.pzembatt_v_batt, 2); file.print("; ");
                file.print(data.pzembatt_i_batt, 3); file.print("; ");
                file.print(data.pzembatt_p_batt, 1); file.print("; ");
                file.print(data.pzembatt_e_batt, 0); file.println();
                file.flush();
                file.close();
                
                Serial.print("‚úç  [PZEMBATT] Data written - No: ");
                Serial.print(data.no);
                Serial.print(" | V:"); Serial.print(data.pzembatt_v_batt, 2);
                Serial.print("V I:"); Serial.print(data.pzembatt_i_batt, 3);
                Serial.print("A P:"); Serial.print(data.pzembatt_p_batt, 1);
                Serial.println("W");
                
                data.pendingWrites &= ~8;  // Clear bit 3
            } else {
                
                sdCardAvailable = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return;
            }
            break;
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE BMS.csv DARI BUFFER (UPDATE) =====
void writeBMSFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Selalu cek SD card sebelum menulis
    if (!checkAndReinitializeSD()) {
        
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Tulis data yang memiliki flag BMS
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 2) {  // Check bit 1
            File file = SD.open("/BMS.csv", FILE_WRITE);
            if (file) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.bms_v1, 3); file.print("; ");      // 3 decimal untuk cell voltage
                file.print(data.bms_v2, 3); file.print("; ");
                file.print(data.bms_v3, 3); file.print("; ");
                file.print(data.bms_v4, 3); file.print("; ");
                file.print(data.bms_total_v, 2); file.print("; ");
                file.print(data.bms_total_i, 2); file.print("; ");
                file.print(data.bms_temp1, 1); file.print("; ");
                file.print(data.bms_temp2, 1); file.print("; ");
                file.print(data.bms_soc, 1); file.println();
                file.close();
                
                Serial.print("‚úç  [BMS] Data written - No: ");
                Serial.print(data.no);
              
                data.pendingWrites &= ~2;  // Clear bit 1
            } else {
                
                // Recovery logic
                
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(200);
                
                if (checkAndReinitializeSD()) {
                    
                    digitalWrite(SPI1_NSS_PIN, LOW);
                    delay(50);
                    
                    File retryFile = SD.open("/BMS.csv", FILE_WRITE);
                    if (retryFile) {
                        retryFile.print(data.no); retryFile.print("; ");
                        retryFile.print(data.timestamp); retryFile.print("; ");
                        retryFile.print(data.bms_v1, 3); retryFile.print("; ");
                        retryFile.print(data.bms_v2, 3); retryFile.print("; ");
                        retryFile.print(data.bms_v3, 3); retryFile.print("; ");
                        retryFile.print(data.bms_v4, 3); retryFile.print("; ");
                        retryFile.print(data.bms_total_v, 2); retryFile.print("; ");
                        retryFile.print(data.bms_total_i, 2); retryFile.print("; ");
                        retryFile.print(data.bms_temp1, 1); retryFile.print("; ");
                        retryFile.print(data.bms_temp2, 1); retryFile.print("; ");
                        retryFile.print(data.bms_soc, 1); retryFile.println();
                        retryFile.flush();
                        retryFile.close();
                        
                        
                        data.pendingWrites &= ~2;
                    } else {
                        
                    }
                }
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE ENERGI.csv DARI BUFFER =====
void writeLOADFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Selalu cek SD card sebelum menulis
    if (!checkAndReinitializeSD()) {
        
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Tulis data yang memiliki flag Energi
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 4) {  // Check bit 2
            File file = SD.open("/LOAD.csv", FILE_WRITE);
            if (file) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.load_plts_p, 1); file.print("; ");
                file.print(data.load_plts_e, 0); file.print("; ");
                file.print(data.energi_lux, 1); file.print("; ");
                file.print(data.energi_temp1, 1); file.print("; ");
                file.print(data.energi_temp2, 1); file.println();
                file.close();
                
                Serial.print("‚úç  [LOAD] Data written - No: ");
                Serial.print(data.no);
                                
                data.pendingWrites &= ~4;  // Clear bit 2
            } else {
                
                
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(200);
                
                if (checkAndReinitializeSD()) {
                    
                    
                    digitalWrite(SPI1_NSS_PIN, LOW);
                    delay(50);
                    
                    File retryFile = SD.open("/LOAD.csv", FILE_WRITE);
                    if (retryFile) {
                        retryFile.print(data.no); retryFile.print("; ");
                        retryFile.print(data.timestamp); retryFile.print("; ");
                        retryFile.print(data.load_plts_p, 1); retryFile.print("; ");
                        retryFile.print(data.load_plts_e, 0); retryFile.print("; ");
                        retryFile.print(data.energi_lux, 1); retryFile.print("; ");
                        retryFile.print(data.energi_temp1, 1); retryFile.print("; ");
                        retryFile.print(data.energi_temp2, 1); retryFile.println();
                        retryFile.flush();
                        retryFile.close();
                        
                        
                        data.pendingWrites &= ~4;
                    } else {
                        
                        delay(500);
                        File finalRetry = SD.open("/LOAD.csv", FILE_WRITE);
                        if (finalRetry) {
                            finalRetry.print(data.no); finalRetry.print("; ");
                            finalRetry.print(data.timestamp); finalRetry.print("; ");
                            finalRetry.print(data.load_plts_p, 1); finalRetry.print("; ");
                            finalRetry.print(data.load_plts_e, 0); finalRetry.print("; ");
                            finalRetry.print(data.energi_lux, 1); finalRetry.print("; ");
                            finalRetry.print(data.energi_temp1, 1); finalRetry.print("; ");
                            finalRetry.print(data.energi_temp2, 1); finalRetry.println();
                            finalRetry.flush();
                            finalRetry.close();
                            
                            data.pendingWrites &= ~4;
                        } else {
                            
                        }
                    }
                } else {
                    
                }
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== CLEANUP BUFFER =====
void cleanupCompletedData() {
    while (!isFIFOEmpty()) {
        DataRecord& data = fifoBuffer[fifoHead];
        if (data.pendingWrites == 0) {
            getFromFIFO();  // Hapus data yang sudah selesai ditulis ke 3 file
            Serial.println("üóë  [FIFO] Data dihapus setelah ditulis ke semua file");
        } else {
            break;  // Hentikan jika masih ada file yang belum ditulis
        }
    }
}

// ===== STATE MACHINE UNTUK PENULISAN FILE SEKUENSIAL =====
void handleWriteStateMachine() {
    unsigned long currentTime = millis();
    
    if (isFIFOEmpty()) {
        currentWriteState = WRITE_IDLE;
        return;
    }
    
    if (currentTime - writeStateTimer >= writeStateDelay) {
        switch (currentWriteState) {
            case WRITE_IDLE:
                if (!isFIFOEmpty()) {
                    currentWriteState = WRITE_PZEMPV;
                    writeStateTimer = currentTime;
                    
                }
                break;
                
            case WRITE_PZEMPV:
                writePZEMPVFromBuffer();
                currentWriteState = WRITE_PZEMBATT;
                writeStateTimer = currentTime;
                
                break;

            case WRITE_PZEMBATT:
                writePZEMBATTFromBuffer();
                currentWriteState = WRITE_BMS;
                writeStateTimer = currentTime;
                
                break;
                
            case WRITE_BMS:
                writeBMSFromBuffer();
                currentWriteState = WRITE_LOAD;
                writeStateTimer = currentTime;
                
                break;
                
            case WRITE_LOAD:
                writeLOADFromBuffer();
                currentWriteState = WRITE_CLEANUP;
                writeStateTimer = currentTime;
                
                break;
                
            case WRITE_CLEANUP:
                cleanupCompletedData();
                currentWriteState = WRITE_IDLE;
                writeStateTimer = currentTime;
                
                break;
        }
    }
}

// ===== FUNGSI DEBUG STATE MACHINE =====
void printWriteState() {
    const char* stateNames[] = {"IDLE", "PZEMPV","PZEMBATT", "BMS", "LOAD", "CLEANUP"};
    Serial.print("üìç [STATE] Current: ");
    Serial.print(stateNames[currentWriteState]);
    Serial.print(" | FIFO Count: ");
    Serial.print(getFIFOCount());
    Serial.print("/");
    Serial.println(FIFO_SIZE);
}

void urgent() {
    // SAFETY: Overcurrent protection SELALU aktif, bahkan di manual mode
    if (PZEMCurrentBattery > 10.0) {
        digitalWrite(RELAY_Batt, LOW);
        Serial.print("‚ö† [SAFETY] OVERCURRENT: "); Serial.print(PZEMCurrentBattery); Serial.println("A > 10.0A - RELAY OFF");
        return;  // Skip auto-control logic
    }
    
    // Skip auto ON jika manual control mode aktif
    if (manualControlMode) {
        return;
    }
    
    // Auto-control: Battery relay ON (hanya jika AUTO mode)
    digitalWrite(RELAY_Batt, HIGH);
}

void initialSOC () {
  if (!soc_initialized && espSOC > 0) {
  SOCo = espSOC;
  soc_initialized = true;
  }
}

void calculateSOC() {
        if (INA219Current < -0.2) { // charging
        if (previousStatus != statusbatt) count = 0;
        count++;
        SOCo += kapasitas;
        statusbatt = 1;
        Serial.println("‚¨Ü  Baterai Charging");
    } else if (INA219Current > 0.2) { // discharging
        if (previousStatus != statusbatt) count = 0;
        count++;
        SOCo -= kapasitas;
        statusbatt = 0;
        Serial.println("‚¨á  Baterai Discharging");
    }
    SOCo = constrain(SOCo, 0, 100);
    SOCt = static_cast<int>(SOCo);
    Serial.print("üìä SOC: "); Serial.print(SOCo, 1); Serial.println("%");
}

void ATS() {
  // Skip jika manual control mode aktif
  if (manualControlMode) {
      return;
  }
  
  // Fungsi ATS - logika SOC telah dihapus
  // Relay dapat dikontrol secara manual via command dari ESP32
  // Serial.println("‚ÑπÔ∏è  ATS: Manual control mode (SOC logic disabled)");
}

void logtoSDcard() {
    // Siapkan data lengkap dari semua sensor dan masukkan ke buffer
    prepareCompleteData();
    
    // Trigger state machine untuk penulisan sekuensial
    if (currentWriteState == WRITE_IDLE && !isFIFOEmpty()) {
        currentWriteState = WRITE_PZEMPV;
        writeStateTimer = millis();
        Serial.println("‚è± [TRIGGER] Penulisan file dimulai");
    }
    
    // Display buffer status
    Serial.print("üìä [FIFO Status] Count: ");
    Serial.print(getFIFOCount());
    Serial.print("/");
    Serial.println(FIFO_SIZE);
}

void loop() {
    currentMillisPZEM = millis();
    currentMillisSOC = millis();
    currentMillisINA = millis();
    currentMillisATS = millis();
    currentMillisSDCheck = millis();

    // Command dari Serial Monitor untuk debug
    if (Serial.available()) {
        String command = Serial.readStringUntil('\n');
        command.trim();
        command.toLowerCase();
        
        if (command == "sd" || command == "sdtest") {
            Serial.println("SD Check...");
            bool result = checkAndReinitializeSD();
            Serial.println(result ? "OK" : "FAILED");
        } else if (command == "sdcheck") {
            Serial.println("üîç Manual SD Check...");
            bool result = checkAndReinitializeSD();
            Serial.println(result ? "‚úÖ SD OK" : "‚ùå SD FAILED");
        } else if (command == "sdinit") {
            Serial.println("üîÑ Manual SD Reinitialization...");
            digitalWrite(SPI1_NSS_PIN, LOW);
            if (SD.begin(SPI1_NSS_PIN)) {
                Serial.println("‚úÖ SD Reinit SUCCESS");
                initializeCSVFiles();
                sdCardAvailable = true;
                sdCardWasRemoved = false;
                isRecursiveCheck = false;
            } else {
                Serial.println("‚ùå SD Reinit FAILED");
                sdCardAvailable = false;
            }
            digitalWrite(SPI1_NSS_PIN, HIGH);
        } else if (command == "reset" || command == "statereset") {
            Serial.println("üîÑ Force Reset State Machine...");
            currentWriteState = WRITE_IDLE;
            writeStateTimer = millis();
            Serial.println("‚úÖ State machine reset to IDLE");
        } else if (command == "fifo" || command == "buffer") {
            Serial.print("üìä [FIFO] Current count: ");
            Serial.print(getFIFOCount());
            Serial.print("/");
            Serial.println(FIFO_SIZE);
            Serial.print("üìç [STATE] Current: ");
            const char* stateNames[] = {"IDLE", "PZEMPV","PZEMBATT", "BMS", "LOAD", "CLEANUP"};
            Serial.println(stateNames[currentWriteState]);
        } else if (command == "clearflag" || command == "clearflags") {
            Serial.println("üßπ Clearing all flags...");
            isRecursiveCheck = false;
            sdCardWasRemoved = false;
            sdCardAvailable = true;
            Serial.println("‚úÖ All flags cleared - system reset");
        } else if (command == "status") {
            Serial.println("üìä === SYSTEM STATUS ===");
            Serial.print("SD Available: "); Serial.println(sdCardAvailable ? "YES" : "NO");
            Serial.print("SD Was Removed: "); Serial.println(sdCardWasRemoved ? "YES" : "NO");
            Serial.print("Recursive Check: "); Serial.println(isRecursiveCheck ? "ACTIVE" : "INACTIVE");
            Serial.print("FIFO Count: "); Serial.print(getFIFOCount()); Serial.print("/"); Serial.println(FIFO_SIZE);
            Serial.print("ESP32 Data: "); Serial.println(espDataReceived ? "READY" : "WAITING");
            const char* stateNames[] = {"IDLE", "PZEMPV","PZEMBATT", "BMS", "LOAD", "CLEANUP"};
            Serial.print("Write State: "); Serial.println(stateNames[currentWriteState]);
            Serial.println("--- TIMESTAMP INFO ---");
            Serial.print("ESP32 Timestamp: "); Serial.println(espTimestamp);
            Serial.print("Global TimeRef: "); Serial.println(globalTimeRef);
            Serial.print("TimeRef Available: "); Serial.println(timeRefAvailable ? "YES" : "NO");
            Serial.print("Current Timestamp: "); Serial.println(getCurrentTimestamp());
            Serial.print("Last ESP32 Update: "); Serial.print((millis() - lastESP32Time) / 1000); Serial.println(" sec ago");
        } else if (command == "esp32" || command == "esp") {
            Serial.println("üì° === ESP32 DATA STATUS ===");
            Serial.print("Data Received: "); Serial.println(espDataReceived ? "YES" : "NO");
            Serial.print("Last Update: "); Serial.print((millis() - lastESP32Time) / 1000); Serial.println(" sec ago");
            Serial.println("--- TIMESTAMP ---");
            Serial.print("ESP32 Timestamp: "); Serial.println(espTimestamp);
            Serial.print("Global TimeRef: "); Serial.println(globalTimeRef);
            Serial.print("TimeRef Available: "); Serial.println(timeRefAvailable ? "YES" : "NO");
            Serial.println("--- SENSOR DATA ---");
            Serial.print("Lux: "); Serial.print(espLux, 1); Serial.println(" lx");
            Serial.print("Temp1: "); Serial.print(espTemp1, 1); Serial.println(" ¬∞C");
            Serial.print("Temp2: "); Serial.print(espTemp2, 1); Serial.println(" ¬∞C");
            Serial.print("BMS Voltage: "); Serial.print(espTotalVoltage, 2); Serial.println(" V");
            Serial.print("BMS Current: "); Serial.print(espTotalCurrent, 2); Serial.println(" A");
            Serial.print("BMS SOC: "); Serial.print(espSOC, 1); Serial.println(" %");
        } else if (command == "timeref" || command == "timeinfo") {
            Serial.println("TimeRef Info:");
            Serial.print("Available: "); Serial.println(timeRefAvailable ? "YES" : "NO");
            Serial.print("TimeRef: "); Serial.println(globalTimeRef);
            Serial.print("Current: "); Serial.println(getCurrentTimestamp());
        } else if (command.startsWith("settime ")) {
            String timestampStr = command.substring(8);
            unsigned long newTimestamp = timestampStr.toInt();
            if (newTimestamp > 1000000) {
                updateTimeRef(newTimestamp);
                Serial.print("‚úÖ [TIMEREF] Manual timestamp set to: ");
                Serial.println(newTimestamp);
            } else {
                Serial.println("‚ùå [TIMEREF] Invalid timestamp (must be > 1000000)");
            }
        } else if (command == "resettimeref") {
            timeRefAvailable = false;
            globalTimeRef = 0;
            globalTimeRefBaseMillis = 0;
            digitalWrite(SPI1_NSS_PIN, LOW);
            if (SD.exists("/timeref.txt")) {
                SD.remove("/timeref.txt");
                Serial.println("üóë [TIMEREF] Removed timeref.txt file");
            }
            digitalWrite(SPI1_NSS_PIN, HIGH);
            Serial.println("TIMEREF RST");
        } else if (command == "resetenergy" || command == "reset") {
            resetAllPZEMEnergy();
        } else if (command == "dummyenergy") {
            PVEnergyBaseline = 0; PVEnergyRaw = 1234; PZEMEnergyPanel = 1234;
            BattEnergyBaseline = 0; BattEnergyRaw = 5678; PZEMEnergyBattery = 5678;
            LoadEnergyBaseline = 0; LoadEnergyRaw = 9012; PLTSEnergy = 9012;
            GridEnergy = 3456;
            Serial.println("Dummy OK");
        } else if (command.startsWith("setenergy ")) {
            float v = command.substring(10).toFloat();
            if (v >= 0) { 
                PVEnergyBaseline = 0; PVEnergyRaw = v; PZEMEnergyPanel = v;
                BattEnergyBaseline = 0; BattEnergyRaw = v; PZEMEnergyBattery = v;
                LoadEnergyBaseline = 0; LoadEnergyRaw = v; PLTSEnergy = v;
                GridEnergy = v; 
                Serial.println("OK"); 
            }
        } else if (command == "energyinfo") {
            Serial.println("=== ENERGY INFO ===");
            Serial.print("PV: Raw="); Serial.print(PVEnergyRaw, 0);
            Serial.print(" Base="); Serial.print(PVEnergyBaseline, 0);
            Serial.print(" Daily="); Serial.println(PZEMEnergyPanel, 0);
            Serial.print("Batt: Raw="); Serial.print(BattEnergyRaw, 0);
            Serial.print(" Base="); Serial.print(BattEnergyBaseline, 0);
            Serial.print(" Daily="); Serial.println(PZEMEnergyBattery, 0);
            Serial.print("Load: Raw="); Serial.print(LoadEnergyRaw, 0);
            Serial.print(" Base="); Serial.print(LoadEnergyBaseline, 0);
            Serial.print(" Daily="); Serial.println(PLTSEnergy, 0);
        } else if (command == "pzemstatus") {
            Serial.println("=== PZEM STATUS ===");
            Serial.print("PV: V="); Serial.print(PZEMVoltagePanel, 1);
            Serial.print(" P="); Serial.print(PZEMPowerPanel, 0);
            Serial.print(" E="); Serial.println(PZEMEnergyPanel, 0);
            Serial.print("Batt: V="); Serial.print(PZEMVoltageBattery, 1);
            Serial.print(" P="); Serial.print(PZEMPowerBattery, 0);
            Serial.print(" E="); Serial.println(PZEMEnergyBattery, 0);
            Serial.print("Load: V="); Serial.print(voltageAC, 1);
            Serial.print(" P="); Serial.print(PLTSPower, 0);
            Serial.print(" E="); Serial.println(PLTSEnergy, 0);
        } else if (command == "controlmode" || command == "mode") {
            Serial.print("Control Mode: ");
            Serial.println(manualControlMode ? "MANUAL (persistent)" : "AUTO");
            Serial.println("Commands: 'automode' to enable auto, 'manualmode' to enable manual");
        } else if (command == "manualmode" || command == "manual") {
            manualControlMode = true;
            Serial.println("[CONTROL] Manual mode ENABLED (persistent until 'automode')");
        } else if (command == "automode" || command == "auto") {
            manualControlMode = false;
            Serial.println("[CONTROL] Auto mode ENABLED");
        } else if (command == "savebaseline" || command == "savebase") {
            saveBaselinesToSD();
        } else if (command == "loadbaseline" || command == "loadbase") {
            loadBaselinesFromSD();
        } else if (command == "baselineinfo" || command == "baseline") {
            Serial.println("========== BASELINE INFO ==========");
            Serial.println("Current Baselines in Memory:");
            Serial.print("  PV Baseline: "); Serial.print(PVEnergyBaseline, 0); Serial.println(" Wh");
            Serial.print("  Batt Baseline: "); Serial.print(BattEnergyBaseline, 0); Serial.println(" Wh");
            Serial.print("  Load Baseline: "); Serial.print(LoadEnergyBaseline, 0); Serial.println(" Wh");
            Serial.println("");
            Serial.println("Current Raw Values from PZEM:");
            Serial.print("  PV Raw: "); Serial.print(PVEnergyRaw, 0); Serial.println(" Wh");
            Serial.print("  Batt Raw: "); Serial.print(BattEnergyRaw, 0); Serial.println(" Wh");
            Serial.print("  Load Raw: "); Serial.print(LoadEnergyRaw, 0); Serial.println(" Wh");
            Serial.println("");
            Serial.println("Calculated Daily Energy:");
            Serial.print("  PV Daily: "); Serial.print(PZEMEnergyPanel, 0); Serial.println(" Wh");
            Serial.print("  Batt Daily: "); Serial.print(PZEMEnergyBattery, 0); Serial.println(" Wh");
            Serial.print("  Load Daily: "); Serial.print(PLTSEnergy, 0); Serial.println(" Wh");
            Serial.println("");
            // Check SD card file
            digitalWrite(SPI1_NSS_PIN, LOW);
            delay(10);
            if (SD.exists("/baseline.txt")) {
                Serial.println("SD Card: /baseline.txt EXISTS");
            } else {
                Serial.println("SD Card: /baseline.txt NOT FOUND");
            }
            digitalWrite(SPI1_NSS_PIN, HIGH);
            Serial.println("===================================");
        } else if (command.startsWith("setbaseline ")) {
            // Format: setbaseline pv 100 atau setbaseline batt 200 atau setbaseline load 300
            String param = command.substring(12);
            param.trim();
            int spacePos = param.indexOf(' ');
            if (spacePos > 0) {
                String sensor = param.substring(0, spacePos);
                float value = param.substring(spacePos + 1).toFloat();
                if (sensor == "pv") {
                    PVEnergyBaseline = value;
                    Serial.print("[SET] PV Baseline = "); Serial.println(value, 0);
                } else if (sensor == "batt") {
                    BattEnergyBaseline = value;
                    Serial.print("[SET] Batt Baseline = "); Serial.println(value, 0);
                } else if (sensor == "load") {
                    LoadEnergyBaseline = value;
                    Serial.print("[SET] Load Baseline = "); Serial.println(value, 0);
                } else {
                    Serial.println("Usage: setbaseline pv|batt|load [value]");
                }
            } else {
                Serial.println("Usage: setbaseline pv|batt|load [value]");
            }
        } else if (command == "resetbaseline" || command == "resetbase") {
            PVEnergyBaseline = PVEnergyRaw;
            BattEnergyBaseline = BattEnergyRaw;
            LoadEnergyBaseline = LoadEnergyRaw;
            Serial.println("[RESET] Baselines set to current raw values:");
            Serial.print("  PV: "); Serial.println(PVEnergyBaseline, 0);
            Serial.print("  Batt: "); Serial.println(BattEnergyBaseline, 0);
            Serial.print("  Load: "); Serial.println(LoadEnergyBaseline, 0);
            saveBaselinesToSD();
        } else if (command == "testmode" || command == "test") {
            testMode = !testMode;
            Serial.print("[TEST MODE] ");
            Serial.println(testMode ? "ENABLED - PZEM reads skipped" : "DISABLED - Normal operation");
        } else if (command.startsWith("setraw ")) {
            // Format: setraw pv 100 atau setraw batt 200 atau setraw load 300
            String param = command.substring(7);
            param.trim();
            int spacePos = param.indexOf(' ');
            if (spacePos > 0) {
                String sensor = param.substring(0, spacePos);
                float value = param.substring(spacePos + 1).toFloat();
                if (sensor == "pv") {
                    PVEnergyRaw = value;
                    Serial.print("[SET] PV Raw = "); Serial.println(value, 0);
                } else if (sensor == "batt") {
                    BattEnergyRaw = value;
                    Serial.print("[SET] Batt Raw = "); Serial.println(value, 0);
                } else if (sensor == "load") {
                    LoadEnergyRaw = value;
                    Serial.print("[SET] Load Raw = "); Serial.println(value, 0);
                } else {
                    Serial.println("Usage: setraw pv|batt|load [value]");
                }
            } else {
                Serial.println("Usage: setraw pv|batt|load [value]");
            }
        } else if (command == "help" || command == "?") {
            Serial.println("======== SERIAL COMMANDS ========");
            Serial.println("baselineinfo / baseline - Show all baseline/raw/daily values");
            Serial.println("savebaseline           - Save baselines to SD card");
            Serial.println("loadbaseline           - Load baselines from SD card");
            Serial.println("resetbaseline / resetbase - Set baselines to current raw values");
            Serial.println("setbaseline pv|batt|load [value] - Set specific baseline");
            Serial.println("setraw pv|batt|load [value]      - Set raw energy value (test)");
            Serial.println("testmode / test        - Toggle test mode (skip PZEM reads)");
            Serial.println("help / ?               - Show this help");
            Serial.println("=================================");
        }
    }

    // Terima data dari ESP32 secara kontinyu (NO TIMER)
    receiveESP32Data();

    // Pengecekan SD Card berkala setiap 30 detik
    if (currentMillisSDCheck - startMillisSDCheck >= periodSDCheck) {
        startMillisSDCheck += periodSDCheck;
        
        bool sdResult = checkAndReinitializeSD();
        if (sdResult) {
            
        } else {
            
        }
    }

    // Baca PZEM setiap 10 detik
    if (currentMillisPZEM - startMillisPZEM >= periodPZEM) {
        startMillisPZEM += periodPZEM;
        readPZEMData();
        
        // Cek apakah perlu reset energy (setiap 24 jam)
        checkAndResetEnergy();
    }

    // Baca INA219 setiap 10 detik
    if (currentMillisINA - startMillisINA >= periodINA) {
        startMillisINA += periodINA;
        readINA219Data();

        // Kirim data sensor ke ESP32
        sendDataToESP();
    }

    // Cek ATS setiap 10 detik
    if (currentMillisATS - startMillisATS >= periodATS) {
        startMillisATS += periodATS;
        urgent();
        ATS();
    }

    // Handle penulisan file secara state machine (jangan blocking)
    handleWriteStateMachine();

    // Logging SOC dan trigger penulisan file setiap 10 detik
    if ((currentMillisSOC - startMillisSOC) >= periodSOC) {
        startMillisSOC += periodSOC;
        initialSOC();  // Inisialisasi SOC dari ESP32 saat pertama kali
        calculateSOC();
        logtoSDcard();
        printWriteState();  // Debug: tampilkan state
    }

    delay(10);  // Small delay to prevent watchdog trigger
}
