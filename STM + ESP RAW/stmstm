#include <ModbusMaster.h>
#include <SPI.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_INA219.h>

// Pin MAX485
#define MAX485_DE      PA0
#define MAX485_RE      PA1

// Pin Relay
#define RELAY_Inv      PB15
#define RELAY_Batt     PB14
#define RELAY_ATS_N    PB13
#define RELAY_ATS_F    PB12

// SPI
#define SPI1_NSS_PIN PA4  // SPI_1 digunakan untuk komunikasi dengan SD Card

// Alamat slave untuk PZEM
static uint8_t pzemSlaveAddrPanel = 0x01;
static uint8_t pzemSlaveAddrBattery = 0x02;
static uint8_t pzemSlaveAddrAC = 0x03;

// Objek ModbusMaster
ModbusMaster nodePanel;
ModbusMaster nodeBattery;
ModbusMaster nodeAC;
Adafruit_INA219 ina219;
 
// Variabel untuk PZEM Panel
float PZEMVoltagePanel = 0.00, PZEMCurrentPanel = 0.00, PZEMPowerPanel = 0.00, PZEMEnergyPanel = 0.00;
float PVEnergyRaw = 0.00;  // Nilai mentah dari PZEM PV
float PVEnergyBaseline = 0.0;  // Baseline untuk daily reset

// Variabel untuk PZEM Baterai
float PZEMVoltageBattery = 0.00, PZEMCurrentBattery = 0.00, PZEMPowerBattery = 0.00, PZEMEnergyBattery = 0.00;
float BattEnergyRaw = 0.00;  // Nilai mentah dari PZEM Battery
float BattEnergyBaseline = 0.0;  // Baseline untuk daily reset

// Variable untuk PSEM AC
float voltageAC, currentAC, powerAC, energyAC, frequencyAC, powerFactorAC;

// Variabel untuk PZEM AC - LOAD MONITORING
// Note: Variable names use "PLTS" for backward compatibility, but these measure LOAD power/energy
float PLTSVoltage = 0.00, PLTSCurrent = 0.00, PLTSPower = 0.00, PLTSEnergy = 0, PLTSHz = 0.00, PLTSPf = 0.00;
float GridVoltage = 0.00, GridCurrent = 0.00, GridPower = 0.00, GridEnergy = 0, GridHz = 0.00, GridPf = 0.00;

// Baseline energy untuk daily reset (SEMUA PZEM pakai baseline method)
float LoadEnergyRaw = 0.0;  // Nilai mentah dari PZEM AC (Load)
float LoadEnergyBaseline = 0.0;  // Baseline untuk daily reset Load

// Energy Offset untuk testing (ditambahkan ke hasil pembacaan PZEM)
float PVEnergyOffset = 0.0;
float BattEnergyOffset = 0.0;
float LoadEnergyOffset = 0.0;

// Variabel untuk INA219
float ShuntVoltage = 0.00, INA219Voltage = 0.00, INA219Current = 0.00;
bool ina219Available = false;  // Flag untuk track status INA219

// Initial SOC
bool soc_initialized = false;  // Global flag

// Tambahan variabel BMS
float v1 = 0.0, v2 = 0.0, v3 = 0.0, v4 = 0.0;
float total_voltage = 0.0, soc = 0.0;
float bms_temp1 = 0.0, bms_temp2 = 0.0;  // <-- BARU: temperature BMS dari ESP32
float bms_current = 0.0;  // <-- BARU: current BMS dari ESP32

// Variabel untuk menerima data ESP32
unsigned long espTimestamp = 0;
float espLux = 0.0, espTemp1 = 0.0, espTemp2 = 0.0;
float espTotalVoltage = 0.0, espTotalCurrent = 0.0, espSOC = 0.0;  // <-- UPDATE: tambah current
float espBMSTemp1 = 0.0, espBMSTemp2 = 0.0;  // <-- BARU: BMS temperature
float espCellV1 = 0.0, espCellV2 = 0.0, espCellV3 = 0.0, espCellV4 = 0.0;  // <-- BARU: Cell voltages
bool espDataReceived = false;
unsigned long lastESP32Time = 0;

// ===== VARIABEL GLOBAL TIMEREF =====
unsigned long globalTimeRef = 0;        // Timestamp referensi global
unsigned long globalTimeRefBaseMillis = 0; // Basis millis() saat timeref di-set
bool timeRefAvailable = false;           // Flag ketersediaan timeref
unsigned long lastTimeRefUpdate = 0;     // Terakhir kali timeref diupdate
const unsigned long timeRefUpdateInterval = 300000; // Update timeref setiap 5 menit

// ===== STRUKTUR DATA UNTUK FIFO BUFFER (UPDATE) =====
struct DataRecord {
    int no;
    char waktu[10];
    unsigned long timestamp;
    float pzempv_v_pv, pzempv_i_pv, pzempv_p_pv, pzempv_e_pv;
    float pzembatt_v_batt, pzembatt_i_batt, pzembatt_p_batt, pzembatt_e_batt, pzembatt_soc;
    float bms_v1, bms_v2, bms_v3, bms_v4, bms_total_v, bms_total_i, bms_soc;  // <-- UPDATE: tambah total_i
    float bms_temp1, bms_temp2;  // <-- BARU: BMS temperatures
    float energi_p_batt, energi_e_batt, energi_soc;
    float load_plts_p, load_plts_e;
    float energi_lux, energi_temp1, energi_temp2;
    int pendingWrites;
};

// FIFO Buffer (ukuran 20 slot)
#define FIFO_SIZE 20
DataRecord fifoBuffer[FIFO_SIZE];
int fifoHead = 0;
int fifoTail = 0;
int fifoCount = 0;

// Timer untuk ESP32
unsigned long startMillisESP;
unsigned long currentMillisESP;
const unsigned long periodESP = 60000;  // 10 detik timeout (disesuaikan dengan testing)

// State Machine untuk penulisan file sekuensial
enum WriteState {
    WRITE_IDLE = 0,
    WRITE_PZEMPV = 1,
    WRITE_PZEMBATT=2,
    WRITE_BMS = 3,
    WRITE_LOAD = 4,
    WRITE_CLEANUP = 5
};
WriteState currentWriteState = WRITE_IDLE;

// Timer untuk state machine penulisan
unsigned long writeStateTimer = 0;
const unsigned long writeStateDelay = 100;  // 100ms delay antar penulisan file (dipercepat untuk testing)

// Pengolahan Data
int previousStatus = -1;  // Inisialisasi dengan nilai tidak valid
int count = 0, SOCt = 0, Ah = 100, interval = 0;
float deltaT = 0.0, SOCo = 0.0, kapasitas = 0.0;
char waktu[10];

// Status Alat Terkini
int statusbatt = 0, statuscsv = 0;

// Variable callback
const char* hari = "";
const char* bulan = "";
int tanggal, tahun, jam, menit, detik;

// Variabel global yang dibutuhkan
bool isPLTS = false;                  // true = relay ON (pakai PLTS)
bool waitToTurnOn = false;           // status delay sebelum ON
unsigned long timeToTurnOn = 0;      // waktu mulai delay

//Timer untuk Pembaharuan Data
unsigned long startMillisPZEM;
unsigned long currentMillisPZEM;
const unsigned long periodPZEM = 60000; // 10 detik (1 cycle untuk testing)

//Timer untuk INA219
unsigned long startMillisINA;
unsigned long currentMillisINA;
const unsigned long periodINA = 60000; // 10 detik (sinkron dengan PZEM)

//Timer untuk ATS
unsigned long startMillisATS;
unsigned long currentMillisATS;
const unsigned long periodATS = 60000; // 10 detik (sinkron dengan PZEM)

//Timer untuk SD CARD (TESTING: 10 detik per cycle - 1 cycle saja)
unsigned long startMillisSOC;
unsigned long currentMillisSOC;
const unsigned long periodSOC = 60000;  // 1 menit untuk 1 cycle testing

//Timer untuk SD Card Check (setiap 30 detik)
unsigned long startMillisSDCheck;
unsigned long currentMillisSDCheck;
const unsigned long periodSDCheck = 60000;  // 30 detik

// Timer untuk Reset Energi PZEM (setiap jam 00:00 WIB)
unsigned long lastEnergyResetTimestamp = 0;  // Timestamp terakhir reset energi
bool energyResetInitialized = false;  // Flag untuk inisialisasi pertama kali
int lastResetDay = -1;  // Hari terakhir reset dilakukan (-1 = belum pernah)
const int TIMEZONE_OFFSET = 7 * 3600;  // WIB = UTC+7 (dalam detik)

// Manual Control Mode - untuk mencegah auto-switching relay
bool manualControlMode = false;  // Flag untuk manual control via web
// Manual control aktif terus sampai command 'automode' diterima

// Status SD Card
bool sdCardAvailable = true;
bool testMode = false; // Skip PZEM reads when true (for testing)
bool sdCardWasRemoved = false;  // Flag untuk track jika SD card pernah dicabut
bool isRecursiveCheck = false;  // Proteksi terhadap rekursi berlebihan

void setup() {
  // Serial Monitor
  Serial.begin(9600);
  while (!Serial);
  
  delay(2000);
  Serial.println("\n[STARTUP]");

  // Komunikasi Antar Perangkat
  Serial2.begin(9600, SERIAL_8N2); // Untuk komunikasi PZEM
  Serial3.begin(9600);  // Untuk komunikasi dengan ESP32 (9600 baud)
  delay(500);

  pinMode(SPI1_NSS_PIN, OUTPUT);
  digitalWrite(SPI1_NSS_PIN, HIGH);

  // Inisialisasi SD Card
  digitalWrite(SPI1_NSS_PIN, LOW);
  if (!SD.begin(SPI1_NSS_PIN)) {
    while (1);
  }
  digitalWrite(SPI1_NSS_PIN, HIGH);
  delay(500);

  // Konfigurasi MAX485
  pinMode(MAX485_RE, OUTPUT);
  pinMode(MAX485_DE, OUTPUT);
  digitalWrite(MAX485_RE, 0);
  digitalWrite(MAX485_DE, 0);

  // Konfigurasi Relay
  pinMode(RELAY_ATS_F, OUTPUT);
  pinMode(RELAY_Inv, OUTPUT);
  pinMode(RELAY_Batt, OUTPUT);
  pinMode(RELAY_ATS_N, OUTPUT);

  digitalWrite(RELAY_ATS_F, HIGH);
  digitalWrite(RELAY_Inv, HIGH);
  digitalWrite(RELAY_Batt, HIGH);
  digitalWrite(RELAY_ATS_N, HIGH);

  // Inisialisasi Modbus
  nodePanel.begin(pzemSlaveAddrPanel, Serial2);
  nodePanel.preTransmission(preTransmission);
  nodePanel.postTransmission(postTransmission);

  nodeBattery.begin(pzemSlaveAddrBattery, Serial2);
  nodeBattery.preTransmission(preTransmission);
  nodeBattery.postTransmission(postTransmission);

  nodeAC.begin(pzemSlaveAddrAC, Serial2);
  nodeAC.preTransmission(preTransmission);
  nodeAC.postTransmission(postTransmission);

  // Inisialisasi I2C (Wire)
  Wire.begin();
  delay(500);
  
  // Inisialisasi INA219
  if (! ina219.begin())
  {
    while (1) 
    {
      delay(10);
    }
  }
  ina219.setCalibration_32V_50A();
  ina219Available = true;

  startMillisPZEM = millis();
  startMillisSOC = millis();
  startMillisESP = millis();
  startMillisINA = millis();
  startMillisATS = millis();
  startMillisSDCheck = millis();
  
  initializeCSVFiles();
  initializeTimeRef();
  loadBaselinesFromSD();
  
  Serial.println("[READY]");
}

void preTransmission() {
  digitalWrite(MAX485_RE, 1);
  digitalWrite(MAX485_DE, 1);
  delay(1);
}

// ===== FUNGSI INISIALISASI FILE CSV =====
void initializeCSVFiles() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // === Inisialisasi PZEMPV.csv ===
    if (!SD.exists("/PZEMPV.csv")) {
        File file = SD.open("/PZEMPV.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;V PV (V);I PV (A);P PV (W);E PV (Wh)");
            file.close();
        }
    }

    // === Inisialisasi PZEMBATT.csv ===
    if (!SD.exists("/PZEMBATT.csv")) {
        File file = SD.open("/PZEMBATT.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;V Batt (V);I Batt (A);P Batt (W);E Batt (Wh)");
            file.close();
        }
    }
    
    // === Inisialisasi BMS.csv ===
    if (!SD.exists("/BMS.csv")) {
        File file = SD.open("/BMS.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;V1 (V);V2 (V);V3 (V);V4 (V);Total Voltage (V);Total Current (A);Temp1 (C);Temp2 (C);SOC (%)");
            file.close();
        }
    }
    
    // === Inisialisasi LOAD&ENV.csv ===
    if (!SD.exists("/LOAD.csv")) {
        File file = SD.open("/LOAD.csv", FILE_WRITE);
        if (file) {
            file.println("No;Timestamp;PLTS Power (W);PLTS Energy (Wh);Lux (lx);Temp1 (C);Temp2 (C)");
            file.close();
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI PENGECEKAN DAN REINISIALISASI SD CARD =====
bool checkAndReinitializeSD() {
    if (isRecursiveCheck) return false;
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    File root = SD.open("/");
    if (!root) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        if (!sdCardWasRemoved) sdCardWasRemoved = true;
        delay(500);
        
        for (int attempt = 1; attempt <= 3; attempt++) {
            digitalWrite(SPI1_NSS_PIN, LOW);
            delay(100);
            if (SD.begin(SPI1_NSS_PIN)) {
                File testAccess = SD.open("/PZEMPV.csv", FILE_WRITE);
                if (testAccess) {
                    testAccess.close();
                } else {
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    delay(500);
                    continue;
                }
                if (!SD.exists("/PZEMPV.csv") || !SD.exists("/BMS.csv")) {
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    initializeCSVFiles();
                }
                currentWriteState = WRITE_IDLE;
                writeStateTimer = millis();
                sdCardAvailable = true;
                sdCardWasRemoved = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return true;
            } else {
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(1000);
            }
        }
        sdCardAvailable = false;
        return false;
    } else {
        root.close();
        File testFile = SD.open("/PZEMPV.csv", FILE_WRITE);
        if (!testFile) {
            digitalWrite(SPI1_NSS_PIN, HIGH);
            if (!isRecursiveCheck) {
                isRecursiveCheck = true;
                delay(500);
                digitalWrite(SPI1_NSS_PIN, LOW);
                delay(100);
                if (SD.begin(SPI1_NSS_PIN)) {
                    File retestFile = SD.open("/PZEMPV.csv", FILE_WRITE);
                    if (retestFile) {
                        retestFile.close();
                        sdCardAvailable = true;
                        digitalWrite(SPI1_NSS_PIN, HIGH);
                        isRecursiveCheck = false;
                        return true;
                    } else {
                        sdCardAvailable = false;
                        digitalWrite(SPI1_NSS_PIN, HIGH);
                        isRecursiveCheck = false;
                        return false;
                    }
                } else {
                    sdCardAvailable = false;
                    digitalWrite(SPI1_NSS_PIN, HIGH);
                    isRecursiveCheck = false;
                    return false;
                }
            } else {
                sdCardAvailable = false;
                return false;
            }
        }
        testFile.close();
        if (sdCardWasRemoved) {
            sdCardWasRemoved = false;
            currentWriteState = WRITE_IDLE;
            writeStateTimer = millis();
        }
        isRecursiveCheck = false;
        sdCardAvailable = true;
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return true;
    }
}

// ===== FUNGSI TIMEREF FILE MANAGEMENT =====
void initializeTimeRef() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    if (SD.exists("/timeref.txt")) {
        loadTimeRefFromSD();
    } else {
        timeRefAvailable = false;
        globalTimeRef = 0;
        globalTimeRefBaseMillis = 0;
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

bool loadTimeRefFromSD() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    File timeRefFile = SD.open("/timeref.txt", FILE_READ);
    if (!timeRefFile) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    String line = timeRefFile.readStringUntil('\n');
    line.trim();
    timeRefFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    if (line.length() > 0) {
        globalTimeRef = line.toInt();
        globalTimeRefBaseMillis = millis();
        timeRefAvailable = true;
        return true;
    }
    return false;
}

bool saveTimeRefToSD(unsigned long timestamp) {
    if (!sdCardAvailable) return false;
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    File timeRefFile = SD.open("/timeref.txt", FILE_WRITE);
    if (!timeRefFile) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    timeRefFile.seek(0);
    timeRefFile.println(timestamp);
    timeRefFile.flush();
    timeRefFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    return true;
}

void updateTimeRef(unsigned long newTimestamp) {
    globalTimeRef = newTimestamp;
    globalTimeRefBaseMillis = millis();
    timeRefAvailable = true;
    lastTimeRefUpdate = millis();
    saveTimeRefToSD(newTimestamp);
}

// ===== FUNGSI KONTROL RELAY VIA COMMAND DARI ESP32 =====
void handleRelayCommand(String command) {
    command.trim();
    
    if (command != "GET_RELAY_STATUS") {
        manualControlMode = true;
    }
    
    if (command == "RELAY_INV_ON") {
        digitalWrite(RELAY_Inv, HIGH);
        Serial3.println("RELAY_INV_STATUS:ON");
    }
    else if (command == "RELAY_INV_OFF") {
        digitalWrite(RELAY_Inv, LOW);
        Serial3.println("RELAY_INV_STATUS:OFF");
    }
    else if (command == "RELAY_BATT_ON") {
        digitalWrite(RELAY_Batt, HIGH);
        Serial3.println("RELAY_BATT_STATUS:ON");
    }
    else if (command == "RELAY_BATT_OFF") {
        digitalWrite(RELAY_Batt, LOW);
        Serial3.println("RELAY_BATT_STATUS:OFF");
    }
    else if (command == "RELAY_ATS_N_ON") {
        digitalWrite(RELAY_ATS_N, HIGH);
        Serial3.println("RELAY_ATS_N_STATUS:ON");
    }
    else if (command == "RELAY_ATS_N_OFF") {
        digitalWrite(RELAY_ATS_N, LOW);
        Serial3.println("RELAY_ATS_N_STATUS:OFF");
    }
    else if (command == "RELAY_ATS_F_ON") {
        digitalWrite(RELAY_ATS_F, HIGH);
        Serial3.println("RELAY_ATS_F_STATUS:ON");
    }
    else if (command == "RELAY_ATS_F_OFF") {
        digitalWrite(RELAY_ATS_F, LOW);
        Serial3.println("RELAY_ATS_F_STATUS:OFF");
    }
    else if (command == "GET_RELAY_STATUS") {
        String s = "RELAY_STATUS:INV=";
        s += digitalRead(RELAY_Inv) ? "ON," : "OFF,";
        s += "BATT=";
        s += digitalRead(RELAY_Batt) ? "ON," : "OFF,";
        s += "ATS_N=";
        s += digitalRead(RELAY_ATS_N) ? "ON," : "OFF,";
        s += "ATS_F=";
        s += digitalRead(RELAY_ATS_F) ? "ON" : "OFF";
        Serial3.println(s);
    }
    else if (command == "DISABLE_AUTO_CONTROL") {
        manualControlMode = true;
        Serial3.println("AUTO_CONTROL:DISABLED");
    }
    else if (command == "ENABLE_AUTO_CONTROL") {
        manualControlMode = false;
        Serial3.println("AUTO_CONTROL:ENABLED");
    }
}

// ===== FUNGSI HELPER UNTUK WAKTU =====
// Mendapatkan jam saat ini (0-23) dari Unix timestamp dengan timezone WIB
int getCurrentHour() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;  // Konversi ke WIB
    return (localTs % 86400) / 3600;  // 86400 detik per hari, 3600 detik per jam
}

// Mendapatkan menit saat ini (0-59)
int getCurrentMinute() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;
    return (localTs % 3600) / 60;
}

// Mendapatkan hari dalam tahun dari Unix timestamp (untuk tracking reset harian)
int getDayOfYear() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;  // Konversi ke WIB
    return (localTs / 86400);  // Jumlah hari sejak epoch
}

unsigned long getCurrentTimestamp() {
    if (!timeRefAvailable) {
        // FALLBACK MECHANISM - prioritas:
        // 1. ESP32 timestamp jika tersedia dan valid
        // 2. Millis/1000 + base offset
        
        if (espTimestamp > 1000000 && espDataReceived) {
            // Gunakan timestamp ESP32 jika valid dan data baru diterima
            return espTimestamp;
        } else {
            // Fallback ke millis dengan base offset 1700000000 (sekitar 2023)
            return 1700000000 + (millis() / 1000);
        }
    }
    
    // Hitung timestamp saat ini berdasarkan timeref + elapsed millis
    unsigned long currentMillis = millis();
    
    // Handle millis overflow (reset setelah ~49 hari)
    if (currentMillis < globalTimeRefBaseMillis) {
        globalTimeRefBaseMillis = currentMillis;
        saveTimeRefToSD(globalTimeRef);
    }
    
    unsigned long elapsedSeconds = (currentMillis - globalTimeRefBaseMillis) / 1000;
    unsigned long currentTimestamp = globalTimeRef + elapsedSeconds;
    
    return currentTimestamp;
}

String getFormattedTimestampFromRef() {
    if (!timeRefAvailable) {
        return "NO_TIMEREF";
    }
    
    unsigned long timestamp = getCurrentTimestamp();
    
    // Simple formatting (akan lebih baik jika ada library time)
    // Format: UNIX_TIMESTAMP untuk sekarang
    return String(timestamp);
}

void postTransmission() {
  delay(3);
  digitalWrite(MAX485_RE, 0);
  digitalWrite(MAX485_DE, 0);
}

// ===== FUNGSI SAVE/LOAD LAST RESET DAY KE SD CARD =====
void saveLastResetDay(int day) {
    if (!sdCardAvailable) return;
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    if (SD.exists("/lastreset.txt")) SD.remove("/lastreset.txt");
    File f = SD.open("/lastreset.txt", FILE_WRITE);
    if (f) { f.println(day); f.flush(); f.close(); }
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

int loadLastResetDay() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    if (!SD.exists("/lastreset.txt")) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return -1;
    }
    File f = SD.open("/lastreset.txt", FILE_READ);
    if (!f) { digitalWrite(SPI1_NSS_PIN, HIGH); return -1; }
    int day = f.readStringUntil('\n').toInt();
    f.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    return day;
}

void handleResetEnergyCommand() {
    unsigned long ts = getCurrentTimestamp();
    unsigned long localTs = ts + TIMEZONE_OFFSET;
    int currentDay = localTs / 86400;
    int lastReset = loadLastResetDay();
    
    Serial.print("[RESET_CMD] last:"); Serial.print(lastReset);
    Serial.print(" curr:"); Serial.println(currentDay);
    
    if (currentDay != lastReset) {
        Serial.println("[RESET] Executing...");
        resetAllPZEMEnergy();
        saveLastResetDay(currentDay);
        Serial.println("[RESET] Done!");
    } else {
        Serial.println("[RESET] Skip (already today)");
    }
}

// ===== FUNGSI SAVE/LOAD BASELINE KE SD CARD =====
void saveBaselinesToSD() {
    if (!sdCardAvailable) return;
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    if (SD.exists("/baseline.txt")) {
        SD.remove("/baseline.txt");
    }
    
    File baselineFile = SD.open("/baseline.txt", FILE_WRITE);
    if (baselineFile) {
        baselineFile.println(PVEnergyBaseline, 0);
        baselineFile.println(BattEnergyBaseline, 0);
        baselineFile.println(LoadEnergyBaseline, 0);
        baselineFile.flush();
        baselineFile.close();
        Serial.println("SD:OK");
    } else {
        Serial.println("SD:ERR");
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

bool loadBaselinesFromSD() {
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    if (!SD.exists("/baseline.txt")) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        PVEnergyBaseline = 0.0;
        BattEnergyBaseline = 0.0;
        LoadEnergyBaseline = 0.0;
        return false;
    }
    
    File baselineFile = SD.open("/baseline.txt", FILE_READ);
    if (!baselineFile) {
        digitalWrite(SPI1_NSS_PIN, HIGH);
        return false;
    }
    
    String line1 = baselineFile.readStringUntil('\n');
    String line2 = baselineFile.readStringUntil('\n');
    String line3 = baselineFile.readStringUntil('\n');
    baselineFile.close();
    digitalWrite(SPI1_NSS_PIN, HIGH);
    
    PVEnergyBaseline = line1.toFloat();
    BattEnergyBaseline = line2.toFloat();
    LoadEnergyBaseline = line3.toFloat();
    
    Serial.print("Base:"); Serial.print(PVEnergyBaseline, 0);
    Serial.print(","); Serial.print(BattEnergyBaseline, 0);
    Serial.print(","); Serial.println(LoadEnergyBaseline, 0);
    
    return true;
}

void resetAllPZEMEnergy() {
    Serial.println("[RESET ALL PZEM]");
    
    // Print BEFORE values
    Serial.print("BEFORE PV:"); Serial.print(PVEnergyRaw, 0);
    Serial.print("/"); Serial.print(PVEnergyBaseline, 0);
    Serial.print("/"); Serial.println(PZEMEnergyPanel, 0);
    
    delay(500);
    
    // Read PV - fresh read with retry
    float tempEnergy = 0;
    bool pvOk = false;
    for (int i = 0; i < 3; i++) {
        while (Serial2.available()) Serial2.read();
        delay(100);
        uint8_t result = nodePanel.readInputRegisters(0x0000, 6);
        if (result == nodePanel.ku8MBSuccess) {
            uint32_t tempdouble = (nodePanel.getResponseBuffer(0x0005) << 16) + nodePanel.getResponseBuffer(0x0004);
            tempEnergy = tempdouble;
            PVEnergyRaw = tempEnergy + PVEnergyOffset;  // Add offset
            PVEnergyBaseline = PVEnergyRaw;
            pvOk = true;
            Serial.print("PV OK:"); Serial.println(PVEnergyBaseline, 0);
            break;
        }
        delay(200);
    }
    if (!pvOk) {
        Serial.println("PV FAIL - using last raw");
        PVEnergyBaseline = PVEnergyRaw;
        Serial.print("PV Fallback:"); Serial.println(PVEnergyBaseline, 0);
    }
    
    delay(500);
    
    // Read Battery - fresh read with retry
    bool battOk = false;
    for (int i = 0; i < 3; i++) {
        while (Serial2.available()) Serial2.read();
        delay(100);
        uint8_t result = nodeBattery.readInputRegisters(0x0000, 6);
        if (result == nodeBattery.ku8MBSuccess) {
            uint32_t tempdouble = (nodeBattery.getResponseBuffer(0x0005) << 16) + nodeBattery.getResponseBuffer(0x0004);
            tempEnergy = tempdouble;
            BattEnergyRaw = tempEnergy + BattEnergyOffset;  // Add offset
            BattEnergyBaseline = BattEnergyRaw;
            battOk = true;
            Serial.print("Batt OK:"); Serial.println(BattEnergyBaseline, 0);
            break;
        }
        delay(200);
    }
    if (!battOk) {
        Serial.println("Batt FAIL - using last raw");
        BattEnergyBaseline = BattEnergyRaw;
        Serial.print("Batt Fallback:"); Serial.println(BattEnergyBaseline, 0);
    }
    
    delay(500);
    
    // Read Load AC - fresh read with retry
    bool loadOk = false;
    for (int i = 0; i < 3; i++) {
        while (Serial2.available()) Serial2.read();
        delay(100);
        uint8_t result = nodeAC.readInputRegisters(0x0000, 9);
        if (result == nodeAC.ku8MBSuccess) {
            uint32_t tempdouble = (nodeAC.getResponseBuffer(0x0006) << 16) + nodeAC.getResponseBuffer(0x0005);
            tempEnergy = tempdouble;
            LoadEnergyRaw = tempEnergy + LoadEnergyOffset;  // Add offset
            LoadEnergyBaseline = LoadEnergyRaw;
            loadOk = true;
            Serial.print("Load OK:"); Serial.println(LoadEnergyBaseline, 0);
            break;
        }
        delay(200);
    }
    if (!loadOk) {
        Serial.println("Load FAIL - using last raw");
        LoadEnergyBaseline = LoadEnergyRaw;
        Serial.print("Load Fallback:"); Serial.println(LoadEnergyBaseline, 0);
    }
    
    // IMMEDIATELY recalculate daily energy to 0
    PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
    if (PZEMEnergyPanel < 0) PZEMEnergyPanel = 0;
    
    PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
    if (PZEMEnergyBattery < 0) PZEMEnergyBattery = 0;
    
    PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
    if (PLTSEnergy < 0) PLTSEnergy = 0;
    
    // Save to SD
    saveBaselinesToSD();
    
    lastEnergyResetTimestamp = getCurrentTimestamp();
    lastResetDay = getDayOfYear();
    
    // Print AFTER values - should all be 0
    Serial.print("AFTER PV:"); Serial.print(PVEnergyRaw, 0);
    Serial.print("/"); Serial.print(PVEnergyBaseline, 0);
    Serial.print("/"); Serial.println(PZEMEnergyPanel, 0);
    Serial.print("AFTER Batt:"); Serial.print(BattEnergyRaw, 0);
    Serial.print("/"); Serial.print(BattEnergyBaseline, 0);
    Serial.print("/"); Serial.println(PZEMEnergyBattery, 0);
    Serial.print("AFTER Load:"); Serial.print(LoadEnergyRaw, 0);
    Serial.print("/"); Serial.print(LoadEnergyBaseline, 0);
    Serial.print("/"); Serial.println(PLTSEnergy, 0);
    
    Serial.println("[RESET OK]");
}

void checkAndResetEnergy() {
    int currentHour = -1;
    int currentDay = -1;
    int currentMinute = -1;
    
    if (timeRefAvailable) {
        currentHour = getCurrentHour();
        currentMinute = getCurrentMinute();
        currentDay = getDayOfYear();
    } else if (espTimestamp > 1000000) {
        unsigned long localTs = espTimestamp + TIMEZONE_OFFSET;
        currentHour = (localTs % 86400) / 3600;
        currentMinute = (localTs % 3600) / 60;
        currentDay = (localTs / 86400);
    } else {
        return;
    }
    
    if (!energyResetInitialized) {
        if (timeRefAvailable) {
            lastEnergyResetTimestamp = getCurrentTimestamp();
        } else {
            lastEnergyResetTimestamp = espTimestamp;
        }
        lastResetDay = currentDay;
        energyResetInitialized = true;
        return;
    }
    
    // Reset at 15:10 WIB
    if (currentHour == 15 && currentMinute >= 10 && currentDay != lastResetDay) {
        Serial.print("[RESET 15:10] day:"); Serial.println(currentDay);
        resetAllPZEMEnergy();
    }
}

void readPZEMDC(ModbusMaster &node, float &voltage, float &current, float &power, float &energy) {
    while (Serial2.available()) Serial2.read(); // Bersihkan buffer serial
    delay(100); // Beri waktu switching RS485
    uint8_t result = node.readInputRegisters(0x0000, 6);
    if (result == node.ku8MBSuccess) {
        uint32_t tempdouble = 0x00000000;
        voltage = node.getResponseBuffer(0x0000) / 100.0;
        current = node.getResponseBuffer(0x0001) / 100.0;
        tempdouble = (node.getResponseBuffer(0x0003) << 16) + node.getResponseBuffer(0x0002);
        power = tempdouble / 10.0;
        tempdouble = (node.getResponseBuffer(0x0005) << 16) + node.getResponseBuffer(0x0004);
        energy = tempdouble;
    } else {
        Serial.print("DC ERR:");
        Serial.println(result, HEX);
    }
}

void readPZEMAC(ModbusMaster &node, float &voltageAC, float &currentAC, float &powerAC, float &energyAC, float &frequencyAC, float &powerFactorAC) {
    while (Serial2.available()) Serial2.read(); // Bersihkan buffer serial
    delay(100); // Beri waktu switching RS485
    uint8_t result = node.readInputRegisters(0x0000, 9);
    if (result == node.ku8MBSuccess) {
        uint32_t tempdouble = 0x00000000;
        voltageAC = node.getResponseBuffer(0x0000) / 10.0;
        tempdouble = (node.getResponseBuffer(0x0002) << 16) + node.getResponseBuffer(0x0001);
        currentAC = tempdouble / 1000.00;
        tempdouble = (node.getResponseBuffer(0x0004) << 16) + node.getResponseBuffer(0x0003);
        powerAC = tempdouble / 10.0;
        tempdouble = (node.getResponseBuffer(0x0006) << 16) + node.getResponseBuffer(0x0005);
        energyAC = tempdouble;
        frequencyAC = node.getResponseBuffer(0x0007) / 10.0;
        powerFactorAC = node.getResponseBuffer(0x0008) / 100.0;
    } else {
        Serial.print("AC ERR:");
        Serial.println(result, HEX);
    }
}

void readPZEMData() {
    if (testMode) {
        Serial.println("[TEST]");
        PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
        if (PZEMEnergyPanel < 0) PZEMEnergyPanel = 0;
        PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
        if (PZEMEnergyBattery < 0) PZEMEnergyBattery = 0;
        PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
        if (PLTSEnergy < 0) PLTSEnergy = 0;
        return;
    }
    
    // Read PV with baseline calculation + offset
    float tempPVEnergy = 0;
    readPZEMDC(nodePanel, PZEMVoltagePanel, PZEMCurrentPanel, PZEMPowerPanel, tempPVEnergy);
    PVEnergyRaw = tempPVEnergy + PVEnergyOffset;  // Add offset
    PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
    if (PZEMEnergyPanel < 0) PZEMEnergyPanel = 0;
    
    Serial.print("PV:"); Serial.print(PZEMVoltagePanel, 1); Serial.print("V ");
    Serial.print(PZEMPowerPanel, 0); Serial.print("W E:"); Serial.println(PZEMEnergyPanel, 0);
    
    delay(200);

    // Read Battery with baseline calculation + offset
    float tempBattEnergy = 0;
    readPZEMDC(nodeBattery, PZEMVoltageBattery, PZEMCurrentBattery, PZEMPowerBattery, tempBattEnergy);
    BattEnergyRaw = tempBattEnergy + BattEnergyOffset;  // Add offset
    PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
    if (PZEMEnergyBattery < 0) PZEMEnergyBattery = 0;
    
    Serial.print("Batt:"); Serial.print(PZEMVoltageBattery, 1); Serial.print("V ");
    Serial.print(PZEMPowerBattery, 0); Serial.print("W E:"); Serial.println(PZEMEnergyBattery, 0);
    
    delay(200);

    // Read Load with baseline calculation + offset
    float tempLoadEnergy = 0;
    readPZEMAC(nodeAC, voltageAC, currentAC, powerAC, tempLoadEnergy, frequencyAC, powerFactorAC);
    LoadEnergyRaw = tempLoadEnergy + LoadEnergyOffset;  // Add offset
    PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
    if (PLTSEnergy < 0) PLTSEnergy = 0;
    
    PLTSVoltage = voltageAC;
    PLTSCurrent = currentAC;
    PLTSPower = powerAC;
    PLTSHz = frequencyAC;
    PLTSPf = powerFactorAC;
    
    Serial.print("Load:"); Serial.print(PLTSVoltage, 1); Serial.print("V ");
    Serial.print(PLTSPower, 0); Serial.print("W E:"); Serial.println(PLTSEnergy, 0);

    delay(200);
}

void readINA219Data() {
    ShuntVoltage = ina219.getShuntVoltage_mV();
    INA219Voltage = ina219.getBusVoltage_V();
    INA219Current = ina219.getCurrent_mA() / 1000.0;
}

void sendDataToESP() {
    // 15 field: PV(4) + Battery(4) + INA219(3) + LOAD(2) + AC PZEM(2)
    // Field 12-13: LOAD Power & Energy (measured by PZEM AC - displayed as "Load" in web interface)
    String data = String(PZEMVoltagePanel) + "," + String(PZEMCurrentPanel) + "," + String(PZEMPowerPanel) + "," + String(PZEMEnergyPanel) + "," +
                  String(PZEMVoltageBattery) + "," + String(PZEMCurrentBattery) + "," + String(PZEMPowerBattery) + "," + String(PZEMEnergyBattery) + "," +
                  String(INA219Voltage) + "," + String(INA219Current) + "," + String(ShuntVoltage) + "," +
                  String(PLTSPower) + "," + String(PLTSEnergy) + "," +
                  String(voltageAC) + "," + String(currentAC) + "\n";
    Serial3.println(data);
}

void addToFIFO(DataRecord data) {
    if (fifoCount < FIFO_SIZE) {
        fifoBuffer[fifoTail] = data;
        fifoTail = (fifoTail + 1) % FIFO_SIZE;
        fifoCount++;
    }
}

DataRecord getFromFIFO() {
    DataRecord data;
    if (fifoCount > 0) {
        data = fifoBuffer[fifoHead];
        fifoHead = (fifoHead + 1) % FIFO_SIZE;
        fifoCount--;
        return data;
    }
    return data;
}

bool isFIFOEmpty() {
    return fifoCount == 0;
}

int getFIFOCount() {
    return fifoCount;
}

// ===== FUNGSI MENERIMA DATA DARI ESP32 =====
void receiveESP32Data() {
    if (Serial3.available()) {
        String receivedData = Serial3.readStringUntil('\n');
        receivedData.trim();
        
        // 0. RESET_ENERGY Command dari ESP32 (jam 00:00 WIB)
        if (receivedData == "RESET_ENERGY") {
            Serial.println("[ESP32] RESET_ENERGY received");
            handleResetEnergyCommand();
            return;
        }
        
        // 1. Relay Command
        if (receivedData.startsWith("RELAY_")) {
            handleRelayCommand(receivedData);
            return;
        }
        
        // 2. Timestamp Sync
        if (receivedData.startsWith("TIMESTAMP_SYNC,")) {
            int firstComma = receivedData.indexOf(',');
            int secondComma = receivedData.indexOf(',', firstComma + 1);
            
            if (firstComma > 0 && secondComma > 0) {
                String timestampStr = receivedData.substring(firstComma + 1, secondComma);
                unsigned long newTimestamp = strtoul(timestampStr.c_str(), NULL, 10);
                
                if (newTimestamp > 1000000 && newTimestamp > globalTimeRef) {
                    updateTimeRef(newTimestamp);
                }
            }
            return;
        }
        
        // 3. Sensor Data (13 fields)
        int commaCount = 0;
        for (int i = 0; i < receivedData.length(); i++) {
            if (receivedData.charAt(i) == ',') commaCount++;
        }
        
        if (commaCount == 12) {
            int pos[13];
            pos[0] = 0;
            int commaIndex = 1;
            
            for (int i = 0; i < receivedData.length() && commaIndex < 13; i++) {
                if (receivedData.charAt(i) == ',') {
                    pos[commaIndex++] = i;
                }
            }
            
            if (commaIndex == 13) {
                String timestampStr = receivedData.substring(pos[0], pos[1]);
                espTimestamp = strtoul(timestampStr.c_str(), NULL, 10);
                Serial.print(timestampStr);
                Serial.print("' -> parsed: ");
                Serial.println(espTimestamp);
                
                espLux = receivedData.substring(pos[1] + 1, pos[2]).toFloat();
                espTemp1 = receivedData.substring(pos[2] + 1, pos[3]).toFloat();
                espTemp2 = receivedData.substring(pos[3] + 1, pos[4]).toFloat();
                espTotalVoltage = receivedData.substring(pos[4] + 1, pos[5]).toFloat();
                espTotalCurrent = receivedData.substring(pos[5] + 1, pos[6]).toFloat();
                espSOC = receivedData.substring(pos[6] + 1, pos[7]).toFloat();
                espBMSTemp1 = receivedData.substring(pos[7] + 1, pos[8]).toFloat();
                espBMSTemp2 = receivedData.substring(pos[8] + 1, pos[9]).toFloat();
                espCellV1 = receivedData.substring(pos[9] + 1, pos[10]).toFloat();
                espCellV2 = receivedData.substring(pos[10] + 1, pos[11]).toFloat();
                espCellV3 = receivedData.substring(pos[11] + 1, pos[12]).toFloat();
                espCellV4 = receivedData.substring(pos[12] + 1).toFloat();
                
                espDataReceived = true;
                lastESP32Time = millis();
                
                // Validasi timestamp
                bool timestampValid = (espTimestamp > 1000000 && espTimestamp < 2147483647);
                
                // UPDATE TIMEREF JIKA TIMESTAMP VALID DAN LEBIH BARU
                if (timestampValid && espTimestamp > globalTimeRef) {
                    if (!timeRefAvailable || (millis() - lastTimeRefUpdate) >= timeRefUpdateInterval) {
                        updateTimeRef(espTimestamp);
                    }
                }
                
                return;
            }
        }
    }
    
    // Check timeout
    currentMillisESP = millis();
    if (espDataReceived && (currentMillisESP - lastESP32Time) >= periodESP) {
        espDataReceived = false;
    }
}

// ===== FUNGSI MEMBUAT DATA LENGKAP UNTUK BUFFER (UPDATE) =====
void prepareCompleteData() {
    if (!espDataReceived) {
        return;
    }
    
    DataRecord newData;
    newData.no = count;
    strcpy(newData.waktu, waktu);
    
    // GUNAKAN TIMESTAMP DARI TIMEREF SEBAGAI SUMBER UTAMA
    newData.timestamp = getCurrentTimestamp();
    
    // Data untuk PZEMPV.csv
    newData.pzempv_v_pv = PZEMVoltagePanel;
    newData.pzempv_i_pv = PZEMCurrentPanel;
    newData.pzempv_p_pv = PZEMPowerPanel;
    newData.pzempv_e_pv = PZEMEnergyPanel;
    
    // Data untuk PZEMBATT.csv
    newData.pzembatt_v_batt = PZEMVoltageBattery;
    newData.pzembatt_i_batt = PZEMCurrentBattery;
    newData.pzembatt_p_batt = PZEMPowerBattery;
    newData.pzembatt_e_batt = PZEMEnergyBattery;
    newData.pzembatt_soc = SOCo;
    
    // Data untuk BMS.csv
    newData.bms_v1 = espCellV1;
    newData.bms_v2 = espCellV2;
    newData.bms_v3 = espCellV3;
    newData.bms_v4 = espCellV4;
    newData.bms_total_v = espTotalVoltage;
    newData.bms_total_i = espTotalCurrent;
    newData.bms_temp1 = espBMSTemp1;
    newData.bms_temp2 = espBMSTemp2;
    newData.bms_soc = espSOC;
    
    // Data untuk LOAD.csv (LOAD monitoring via PZEM AC)
    newData.energi_p_batt = PZEMPowerBattery;
    newData.energi_e_batt = PZEMEnergyBattery;
    newData.energi_soc = SOCo;
    newData.load_plts_p = PLTSPower;  // This is actually LOAD power
    newData.load_plts_e = PLTSEnergy;  // This is actually LOAD energy
    newData.energi_lux = espLux;
    newData.energi_temp1 = espTemp1;
    newData.energi_temp2 = espTemp2;
    
    // Bitmask penulisan: bit 0=PZEMPV, bit 1=BMS, bit 2=LOAD, bit 3=PZEMBATT
    // Total: 1 + 2 + 4 + 8 = 15 (semua file)
    newData.pendingWrites = 15;
    
    addToFIFO(newData);
    espDataReceived = false;
    
    Serial.print("üìù [BUFFER] Data ditambahkan! Timestamp: ");
    Serial.print(newData.timestamp);
    Serial.print(" | PendingWrites: ");
    Serial.println(newData.pendingWrites);
    Serial.print("   PZEMPV: V:"); Serial.print(newData.pzempv_v_pv, 2);
    Serial.print("V | PZEMBATT: V:"); Serial.print(newData.pzembatt_v_batt, 2);
    Serial.println("V");
}

// ===== FUNGSI MENULIS DATA KE PZEMPV.csv DARI BUFFER =====
void writePZEMPVFromBuffer() {
    if (isFIFOEmpty()) return;
    bool sdReady = checkAndReinitializeSD();
    if (!sdReady) return;
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    // Tulis data yang memiliki flag PZEMPV (bit 0)
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 1) {  // Check bit 0
            File file;
            bool fileOpened = false;
            
            for (int openAttempt = 1; openAttempt <= 3; openAttempt++) {
                file = SD.open("/PZEMPV.csv", FILE_WRITE);
                if (file) {
                    fileOpened = true;
                    break;
                } else {
                    delay(100);
                }
            }
            
            if (fileOpened) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.pzempv_v_pv, 2); file.print("; ");
                file.print(data.pzempv_i_pv, 3); file.print("; ");
                file.print(data.pzempv_p_pv, 1); file.print("; ");
                file.print(data.pzempv_e_pv, 0); file.println();
                file.flush();
                file.close();
                
                data.pendingWrites &= ~1;
            } else {
                
                sdCardAvailable = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return;
            }
            break;
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE PZEMBATT.csv DARI BUFFER =====
void writePZEMBATTFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Cek SD card sebelum menulis
    
    bool sdReady = checkAndReinitializeSD();
    
    if (!sdReady) {
        
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    delay(10);
    
    // Tulis data yang memiliki flag PZEMBATT (bit 3)
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 8) {
            File file;
            bool fileOpened = false;
            
            for (int openAttempt = 1; openAttempt <= 3; openAttempt++) {
                file = SD.open("/PZEMBATT.csv", FILE_WRITE);
                if (file) {
                    fileOpened = true;
                    break;
                } else {
                    delay(100);
                }
            }
            
            if (fileOpened) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.pzembatt_v_batt, 2); file.print("; ");
                file.print(data.pzembatt_i_batt, 3); file.print("; ");
                file.print(data.pzembatt_p_batt, 1); file.print("; ");
                file.print(data.pzembatt_e_batt, 0); file.println();
                file.flush();
                file.close();
                
                data.pendingWrites &= ~8;
            } else {
                
                sdCardAvailable = false;
                digitalWrite(SPI1_NSS_PIN, HIGH);
                return;
            }
            break;
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE BMS.csv DARI BUFFER (UPDATE) =====
void writeBMSFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Selalu cek SD card sebelum menulis
    if (!checkAndReinitializeSD()) {
        
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Tulis data yang memiliki flag BMS
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 2) {  // Check bit 1
            File file = SD.open("/BMS.csv", FILE_WRITE);
            if (file) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.bms_v1, 3); file.print("; ");
                file.print(data.bms_v2, 3); file.print("; ");
                file.print(data.bms_v3, 3); file.print("; ");
                file.print(data.bms_v4, 3); file.print("; ");
                file.print(data.bms_total_v, 2); file.print("; ");
                file.print(data.bms_total_i, 2); file.print("; ");
                file.print(data.bms_temp1, 1); file.print("; ");
                file.print(data.bms_temp2, 1); file.print("; ");
                file.print(data.bms_soc, 1); file.println();
                file.close();
              
                data.pendingWrites &= ~2;
            } else {
                
                // Recovery logic
                
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(200);
                
                if (checkAndReinitializeSD()) {
                    
                    digitalWrite(SPI1_NSS_PIN, LOW);
                    delay(50);
                    
                    File retryFile = SD.open("/BMS.csv", FILE_WRITE);
                    if (retryFile) {
                        retryFile.print(data.no); retryFile.print("; ");
                        retryFile.print(data.timestamp); retryFile.print("; ");
                        retryFile.print(data.bms_v1, 3); retryFile.print("; ");
                        retryFile.print(data.bms_v2, 3); retryFile.print("; ");
                        retryFile.print(data.bms_v3, 3); retryFile.print("; ");
                        retryFile.print(data.bms_v4, 3); retryFile.print("; ");
                        retryFile.print(data.bms_total_v, 2); retryFile.print("; ");
                        retryFile.print(data.bms_total_i, 2); retryFile.print("; ");
                        retryFile.print(data.bms_temp1, 1); retryFile.print("; ");
                        retryFile.print(data.bms_temp2, 1); retryFile.print("; ");
                        retryFile.print(data.bms_soc, 1); retryFile.println();
                        retryFile.flush();
                        retryFile.close();
                        
                        
                        data.pendingWrites &= ~2;
                    } else {
                        
                    }
                }
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== FUNGSI MENULIS DATA KE ENERGI.csv DARI BUFFER =====
void writeLOADFromBuffer() {
    if (isFIFOEmpty()) {
        return;
    }
    
    // Selalu cek SD card sebelum menulis
    if (!checkAndReinitializeSD()) {
        
        return;
    }
    
    digitalWrite(SPI1_NSS_PIN, LOW);
    
    // Tulis data yang memiliki flag Energi
    for (int i = 0; i < fifoCount; i++) {
        int index = (fifoHead + i) % FIFO_SIZE;
        DataRecord& data = fifoBuffer[index];
        
        if (data.pendingWrites & 4) {
            File file = SD.open("/LOAD.csv", FILE_WRITE);
            if (file) {
                file.print(data.no); file.print("; ");
                file.print(data.timestamp); file.print("; ");
                file.print(data.load_plts_p, 1); file.print("; ");
                file.print(data.load_plts_e, 0); file.print("; ");
                file.print(data.energi_lux, 1); file.print("; ");
                file.print(data.energi_temp1, 1); file.print("; ");
                file.print(data.energi_temp2, 1); file.println();
                file.close();
                                
                data.pendingWrites &= ~4;
            } else {
                
                
                digitalWrite(SPI1_NSS_PIN, HIGH);
                delay(200);
                
                if (checkAndReinitializeSD()) {
                    
                    
                    digitalWrite(SPI1_NSS_PIN, LOW);
                    delay(50);
                    
                    File retryFile = SD.open("/LOAD.csv", FILE_WRITE);
                    if (retryFile) {
                        retryFile.print(data.no); retryFile.print("; ");
                        retryFile.print(data.timestamp); retryFile.print("; ");
                        retryFile.print(data.load_plts_p, 1); retryFile.print("; ");
                        retryFile.print(data.load_plts_e, 0); retryFile.print("; ");
                        retryFile.print(data.energi_lux, 1); retryFile.print("; ");
                        retryFile.print(data.energi_temp1, 1); retryFile.print("; ");
                        retryFile.print(data.energi_temp2, 1); retryFile.println();
                        retryFile.flush();
                        retryFile.close();
                        
                        
                        data.pendingWrites &= ~4;
                    } else {
                        
                        delay(500);
                        File finalRetry = SD.open("/LOAD.csv", FILE_WRITE);
                        if (finalRetry) {
                            finalRetry.print(data.no); finalRetry.print("; ");
                            finalRetry.print(data.timestamp); finalRetry.print("; ");
                            finalRetry.print(data.load_plts_p, 1); finalRetry.print("; ");
                            finalRetry.print(data.load_plts_e, 0); finalRetry.print("; ");
                            finalRetry.print(data.energi_lux, 1); finalRetry.print("; ");
                            finalRetry.print(data.energi_temp1, 1); finalRetry.print("; ");
                            finalRetry.print(data.energi_temp2, 1); finalRetry.println();
                            finalRetry.flush();
                            finalRetry.close();
                            
                            data.pendingWrites &= ~4;
                        } else {
                            
                        }
                    }
                } else {
                    
                }
            }
            break;  // Tulis satu data sekaligus
        }
    }
    
    digitalWrite(SPI1_NSS_PIN, HIGH);
}

// ===== CLEANUP BUFFER =====
void cleanupCompletedData() {
    while (!isFIFOEmpty()) {
        DataRecord& data = fifoBuffer[fifoHead];
        if (data.pendingWrites == 0) {
            getFromFIFO();
        } else {
            break;
        }
    }
}

// ===== STATE MACHINE UNTUK PENULISAN FILE SEKUENSIAL =====
void handleWriteStateMachine() {
    unsigned long currentTime = millis();
    
    if (isFIFOEmpty()) {
        currentWriteState = WRITE_IDLE;
        return;
    }
    
    if (currentTime - writeStateTimer >= writeStateDelay) {
        switch (currentWriteState) {
            case WRITE_IDLE:
                if (!isFIFOEmpty()) {
                    currentWriteState = WRITE_PZEMPV;
                    writeStateTimer = currentTime;
                    
                }
                break;
                
            case WRITE_PZEMPV:
                writePZEMPVFromBuffer();
                currentWriteState = WRITE_PZEMBATT;
                writeStateTimer = currentTime;
                
                break;

            case WRITE_PZEMBATT:
                writePZEMBATTFromBuffer();
                currentWriteState = WRITE_BMS;
                writeStateTimer = currentTime;
                
                break;
                
            case WRITE_BMS:
                writeBMSFromBuffer();
                currentWriteState = WRITE_LOAD;
                writeStateTimer = currentTime;
                
                break;
                
            case WRITE_LOAD:
                writeLOADFromBuffer();
                currentWriteState = WRITE_CLEANUP;
                writeStateTimer = currentTime;
                
                break;
                
            case WRITE_CLEANUP:
                cleanupCompletedData();
                currentWriteState = WRITE_IDLE;
                writeStateTimer = currentTime;
                
                break;
        }
    }
}

// ===== FUNGSI DEBUG STATE MACHINE =====
void printWriteState() {
    Serial.print("S:"); Serial.print(currentWriteState);
    Serial.print(" F:"); Serial.print(getFIFOCount());
    Serial.print("/"); Serial.println(FIFO_SIZE);
}

void urgent() {
    if (PZEMCurrentBattery > 10.0) {
        digitalWrite(RELAY_Batt, LOW);
        Serial.println("OVERCURR!");
        return;
    }
    
    if (manualControlMode) {
        return;
    }
    
    digitalWrite(RELAY_Batt, HIGH);
}

void initialSOC () {
  if (!soc_initialized && espSOC > 0) {
  SOCo = espSOC;
  soc_initialized = true;
  }
}

void calculateSOC() {
        if (INA219Current < -0.2) {
        if (previousStatus != statusbatt) count = 0;
        count++;
        SOCo += kapasitas;
        statusbatt = 1;
    } else if (INA219Current > 0.2) {
        if (previousStatus != statusbatt) count = 0;
        count++;
        SOCo -= kapasitas;
        statusbatt = 0;
    }
    SOCo = constrain(SOCo, 0, 100);
    SOCt = static_cast<int>(SOCo);
}

void ATS() {
  // Skip jika manual control mode aktif
  if (manualControlMode) {
      return;
  }
  
  // Fungsi ATS - logika SOC telah dihapus
  // Relay dapat dikontrol secara manual via command dari ESP32
  // Serial.println("‚ÑπÔ∏è  ATS: Manual control mode (SOC logic disabled)");
}

void logtoSDcard() {
    prepareCompleteData();
    
    if (currentWriteState == WRITE_IDLE && !isFIFOEmpty()) {
        currentWriteState = WRITE_PZEMPV;
        writeStateTimer = millis();
    }
}

void loop() {
    currentMillisPZEM = millis();
    currentMillisSOC = millis();
    currentMillisINA = millis();
    currentMillisATS = millis();
    currentMillisSDCheck = millis();

    // Command dari Serial Monitor untuk debug
    if (Serial.available()) {
        String command = Serial.readStringUntil('\n');
        command.trim();
        command.toLowerCase();
        
        if (command == "sd" || command == "sdtest") {
            bool result = checkAndReinitializeSD();
            Serial.println(result ? "OK" : "FAILED");
        } else if (command == "sdcheck") {
            bool result = checkAndReinitializeSD();
            Serial.println(result ? "OK" : "FAILED");
        } else if (command == "sdinit") {
            digitalWrite(SPI1_NSS_PIN, LOW);
            if (SD.begin(SPI1_NSS_PIN)) {
                Serial.println("OK");
                initializeCSVFiles();
                sdCardAvailable = true;
                sdCardWasRemoved = false;
                isRecursiveCheck = false;
            } else {
                Serial.println("FAIL");
                sdCardAvailable = false;
            }
            digitalWrite(SPI1_NSS_PIN, HIGH);
        } else if (command == "reset" || command == "statereset") {
            currentWriteState = WRITE_IDLE;
            writeStateTimer = millis();
            Serial.println("RST OK");
        } else if (command == "fifo" || command == "buffer") {
            Serial.print("FIFO:"); Serial.print(getFIFOCount());
            Serial.print("/"); Serial.print(FIFO_SIZE);
            Serial.print(" S:"); Serial.println(currentWriteState);
        } else if (command == "clearflag" || command == "clearflags") {
            isRecursiveCheck = false;
            sdCardWasRemoved = false;
            sdCardAvailable = true;
            Serial.println("CLR OK");
        } else if (command == "status") {
            Serial.print("SD:"); Serial.println(sdCardAvailable);
            Serial.print("FIFO:"); Serial.print(getFIFOCount()); Serial.print("/"); Serial.println(FIFO_SIZE);
            Serial.print("ESP:"); Serial.println(espDataReceived);
            Serial.print("TS:"); Serial.println(getCurrentTimestamp());
        } else if (command == "esp32" || command == "esp") {
            Serial.print("Lux:"); Serial.print(espLux, 0);
            Serial.print(" T1:"); Serial.print(espTemp1, 1);
            Serial.print(" T2:"); Serial.println(espTemp2, 1);
            Serial.print("BMS V:"); Serial.print(espTotalVoltage, 2);
            Serial.print(" I:"); Serial.print(espTotalCurrent, 2);
            Serial.print(" SOC:"); Serial.println(espSOC, 1);
        } else if (command == "timeref" || command == "timeinfo") {
            Serial.print("Ref:"); Serial.println(timeRefAvailable);
            Serial.print("TS:"); Serial.println(getCurrentTimestamp());
        } else if (command.startsWith("settime ")) {
            String timestampStr = command.substring(8);
            unsigned long newTimestamp = timestampStr.toInt();
            if (newTimestamp > 1000000) {
                updateTimeRef(newTimestamp);
                Serial.println(newTimestamp);
            } else {
                Serial.println("ERR");
            }
        } else if (command == "resettimeref") {
            timeRefAvailable = false;
            globalTimeRef = 0;
            globalTimeRefBaseMillis = 0;
            digitalWrite(SPI1_NSS_PIN, LOW);
            if (SD.exists("/timeref.txt")) {
                SD.remove("/timeref.txt");
            }
            digitalWrite(SPI1_NSS_PIN, HIGH);
            Serial.println("OK");
        } else if (command == "resetenergy" || command == "reset") {
            resetAllPZEMEnergy();
        } else if (command == "dummyenergy") {
            PVEnergyBaseline = 0; PVEnergyRaw = 1234; PZEMEnergyPanel = 1234;
            BattEnergyBaseline = 0; BattEnergyRaw = 5678; PZEMEnergyBattery = 5678;
            LoadEnergyBaseline = 0; LoadEnergyRaw = 9012; PLTSEnergy = 9012;
            GridEnergy = 3456;
            Serial.println("OK");
        } else if (command.startsWith("setenergy ")) {
            float v = command.substring(10).toFloat();
            if (v >= 0) { 
                PVEnergyBaseline = 0; PVEnergyRaw = v; PZEMEnergyPanel = v;
                BattEnergyBaseline = 0; BattEnergyRaw = v; PZEMEnergyBattery = v;
                LoadEnergyBaseline = 0; LoadEnergyRaw = v; PLTSEnergy = v;
                GridEnergy = v; 
                Serial.println("OK"); 
            }
        } else if (command.startsWith("addenergy ")) {
            // Menambah nilai energy tanpa menimpa data PZEM asli
            String param = command.substring(10);
            param.trim();
            int sp = param.indexOf(' ');
            if (sp > 0) {
                // Format: addenergy pv|batt|load [value]
                String s = param.substring(0, sp);
                float v = param.substring(sp + 1).toFloat();
                if (s == "pv") {
                    PVEnergyRaw += v;
                    PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
                    Serial.print("PV+"); Serial.print(v, 0);
                    Serial.print("="); Serial.println(PZEMEnergyPanel, 0);
                } else if (s == "batt") {
                    BattEnergyRaw += v;
                    PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
                    Serial.print("Batt+"); Serial.print(v, 0);
                    Serial.print("="); Serial.println(PZEMEnergyBattery, 0);
                } else if (s == "load") {
                    LoadEnergyRaw += v;
                    PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
                    Serial.print("Load+"); Serial.print(v, 0);
                    Serial.print("="); Serial.println(PLTSEnergy, 0);
                } else if (s == "all") {
                    PVEnergyRaw += v; PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
                    BattEnergyRaw += v; PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
                    LoadEnergyRaw += v; PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
                    Serial.print("All+"); Serial.println(v, 0);
                }
            } else {
                // Format: addenergy [value] - tambah ke semua
                float v = param.toFloat();
                if (v != 0) {
                    PVEnergyRaw += v; PZEMEnergyPanel = PVEnergyRaw - PVEnergyBaseline;
                    BattEnergyRaw += v; PZEMEnergyBattery = BattEnergyRaw - BattEnergyBaseline;
                    LoadEnergyRaw += v; PLTSEnergy = LoadEnergyRaw - LoadEnergyBaseline;
                    Serial.print("All+"); Serial.print(v, 0);
                    Serial.print(" PV:"); Serial.print(PZEMEnergyPanel, 0);
                    Serial.print(" Batt:"); Serial.print(PZEMEnergyBattery, 0);
                    Serial.print(" Load:"); Serial.println(PLTSEnergy, 0);
                }
            }
        } else if (command == "energyinfo") {
            Serial.print("PV:"); Serial.print(PVEnergyRaw, 0);
            Serial.print("/"); Serial.print(PVEnergyBaseline, 0);
            Serial.print("/"); Serial.println(PZEMEnergyPanel, 0);
            Serial.print("Batt:"); Serial.print(BattEnergyRaw, 0);
            Serial.print("/"); Serial.print(BattEnergyBaseline, 0);
            Serial.print("/"); Serial.println(PZEMEnergyBattery, 0);
            Serial.print("Load:"); Serial.print(LoadEnergyRaw, 0);
            Serial.print("/"); Serial.print(LoadEnergyBaseline, 0);
            Serial.print("/"); Serial.println(PLTSEnergy, 0);
        } else if (command == "pzemstatus") {
            Serial.print("PV:"); Serial.print(PZEMVoltagePanel, 1);
            Serial.print("V "); Serial.print(PZEMPowerPanel, 0);
            Serial.print("W "); Serial.println(PZEMEnergyPanel, 0);
            Serial.print("Batt:"); Serial.print(PZEMVoltageBattery, 1);
            Serial.print("V "); Serial.print(PZEMPowerBattery, 0);
            Serial.print("W "); Serial.println(PZEMEnergyBattery, 0);
            Serial.print("Load:"); Serial.print(voltageAC, 1);
            Serial.print("V "); Serial.print(PLTSPower, 0);
            Serial.print("W "); Serial.println(PLTSEnergy, 0);
        } else if (command == "controlmode" || command == "mode") {
            Serial.println(manualControlMode ? "MANUAL" : "AUTO");
        } else if (command == "manualmode" || command == "manual") {
            manualControlMode = true;
            Serial.println("MANUAL");
        } else if (command == "automode" || command == "auto") {
            manualControlMode = false;
            Serial.println("AUTO");
        } else if (command == "savebaseline" || command == "savebase") {
            saveBaselinesToSD();
        } else if (command == "loadbaseline" || command == "loadbase") {
            loadBaselinesFromSD();
        } else if (command == "baselineinfo" || command == "baseline") {
            Serial.print("Base PV:"); Serial.print(PVEnergyBaseline, 0);
            Serial.print(" Batt:"); Serial.print(BattEnergyBaseline, 0);
            Serial.print(" Load:"); Serial.println(LoadEnergyBaseline, 0);
            Serial.print("Raw  PV:"); Serial.print(PVEnergyRaw, 0);
            Serial.print(" Batt:"); Serial.print(BattEnergyRaw, 0);
            Serial.print(" Load:"); Serial.println(LoadEnergyRaw, 0);
            Serial.print("Daily PV:"); Serial.print(PZEMEnergyPanel, 0);
            Serial.print(" Batt:"); Serial.print(PZEMEnergyBattery, 0);
            Serial.print(" Load:"); Serial.println(PLTSEnergy, 0);
            digitalWrite(SPI1_NSS_PIN, LOW);
            delay(10);
            Serial.println(SD.exists("/baseline.txt") ? "SD:OK" : "SD:NO");
            digitalWrite(SPI1_NSS_PIN, HIGH);
        } else if (command.startsWith("setbaseline ")) {
            String param = command.substring(12);
            param.trim();
            int sp = param.indexOf(' ');
            if (sp > 0) {
                String s = param.substring(0, sp);
                float v = param.substring(sp + 1).toFloat();
                if (s == "pv") { PVEnergyBaseline = v; Serial.println(v, 0); }
                else if (s == "batt") { BattEnergyBaseline = v; Serial.println(v, 0); }
                else if (s == "load") { LoadEnergyBaseline = v; Serial.println(v, 0); }
            }
        } else if (command == "resetbaseline" || command == "resetbase") {
            PVEnergyBaseline = PVEnergyRaw;
            BattEnergyBaseline = BattEnergyRaw;
            LoadEnergyBaseline = LoadEnergyRaw;
            Serial.println("Reset OK");
            saveBaselinesToSD();
        } else if (command == "testmode" || command == "test") {
            testMode = !testMode;
            Serial.println(testMode ? "Test ON" : "Test OFF");
        } else if (command.startsWith("setraw ")) {
            String param = command.substring(7);
            param.trim();
            int sp = param.indexOf(' ');
            if (sp > 0) {
                String s = param.substring(0, sp);
                float v = param.substring(sp + 1).toFloat();
                if (s == "pv") { PVEnergyRaw = v; Serial.println(v, 0); }
                else if (s == "batt") { BattEnergyRaw = v; Serial.println(v, 0); }
                else if (s == "load") { LoadEnergyRaw = v; Serial.println(v, 0); }
            }
        } else if (command.startsWith("addoffset ")) {
            // Format: addoffset pv|batt|load|all [value]
            String param = command.substring(10);
            param.trim();
            int sp = param.indexOf(' ');
            if (sp > 0) {
                String s = param.substring(0, sp);
                float v = param.substring(sp + 1).toFloat();
                if (s == "pv") { PVEnergyOffset += v; Serial.print("PV Offset:"); Serial.println(PVEnergyOffset, 0); }
                else if (s == "batt") { BattEnergyOffset += v; Serial.print("Batt Offset:"); Serial.println(BattEnergyOffset, 0); }
                else if (s == "load") { LoadEnergyOffset += v; Serial.print("Load Offset:"); Serial.println(LoadEnergyOffset, 0); }
                else if (s == "all") {
                    PVEnergyOffset += v; BattEnergyOffset += v; LoadEnergyOffset += v;
                    Serial.print("All Offset +"); Serial.println(v, 0);
                }
            } else {
                float v = param.toFloat();
                if (v != 0) {
                    PVEnergyOffset += v; BattEnergyOffset += v; LoadEnergyOffset += v;
                    Serial.print("All Offset +"); Serial.println(v, 0);
                }
            }
        } else if (command.startsWith("setoffset ")) {
            // Format: setoffset pv|batt|load [value]
            String param = command.substring(10);
            param.trim();
            int sp = param.indexOf(' ');
            if (sp > 0) {
                String s = param.substring(0, sp);
                float v = param.substring(sp + 1).toFloat();
                if (s == "pv") { PVEnergyOffset = v; Serial.println(v, 0); }
                else if (s == "batt") { BattEnergyOffset = v; Serial.println(v, 0); }
                else if (s == "load") { LoadEnergyOffset = v; Serial.println(v, 0); }
            }
        } else if (command == "clearoffset" || command == "offsetclear") {
            PVEnergyOffset = 0; BattEnergyOffset = 0; LoadEnergyOffset = 0;
            Serial.println("Offset cleared");
        } else if (command == "offsetinfo" || command == "offset") {
            Serial.print("Offset PV:"); Serial.print(PVEnergyOffset, 0);
            Serial.print(" Batt:"); Serial.print(BattEnergyOffset, 0);
            Serial.print(" Load:"); Serial.println(LoadEnergyOffset, 0);
        } else if (command == "help" || command == "?") {
            Serial.println("baseline,savebaseline,loadbaseline,resetbaseline");
            Serial.println("setbaseline pv|batt|load [v],setraw pv|batt|load [v]");
            Serial.println("addenergy [v] | addenergy pv|batt|load|all [v]");
            Serial.println("addoffset [v] | setoffset pv|batt|load [v] | clearoffset");
            Serial.println("resetenergy,energyinfo,offsetinfo,testmode,help");
        }
    }

    // Terima data dari ESP32 secara kontinyu (NO TIMER)
    receiveESP32Data();

    // Pengecekan SD Card berkala setiap 30 detik
    if (currentMillisSDCheck - startMillisSDCheck >= periodSDCheck) {
        startMillisSDCheck += periodSDCheck;
        
        bool sdResult = checkAndReinitializeSD();
        if (sdResult) {
            
        } else {
            
        }
    }

    // Baca PZEM setiap 10 detik
    if (currentMillisPZEM - startMillisPZEM >= periodPZEM) {
        startMillisPZEM += periodPZEM;
        readPZEMData();
        
        // Cek apakah perlu reset energy (setiap 24 jam)
        checkAndResetEnergy();
    }

    // Baca INA219 setiap 10 detik
    if (currentMillisINA - startMillisINA >= periodINA) {
        startMillisINA += periodINA;
        readINA219Data();

        // Kirim data sensor ke ESP32
        sendDataToESP();
    }

    // Cek ATS setiap 10 detik
    if (currentMillisATS - startMillisATS >= periodATS) {
        startMillisATS += periodATS;
        urgent();
        ATS();
    }

    // Handle penulisan file secara state machine (jangan blocking)
    handleWriteStateMachine();

    // Logging SOC dan trigger penulisan file setiap 10 detik
    if ((currentMillisSOC - startMillisSOC) >= periodSOC) {
        startMillisSOC += periodSOC;
        initialSOC();  // Inisialisasi SOC dari ESP32 saat pertama kali
        calculateSOC();
        logtoSDcard();
        printWriteState();  // Debug: tampilkan state
    }

    delay(10);  // Small delay to prevent watchdog trigger
}
